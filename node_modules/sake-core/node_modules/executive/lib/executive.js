'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var child_process = require('child_process');
var Stream = _interopDefault(require('stream'));
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));

// node_modules/es-tostring/index.mjs
var toString = function(obj) {
  return Object.prototype.toString.call(obj)
};

// node_modules/es-hasown/index.mjs
var hasOwn = function(obj, prop) {
  return {}.hasOwnProperty.call(obj, prop)
};

// node_modules/es-is/bool.js
// Generated by CoffeeScript 1.12.5
var isBool;

var isBool$1 = isBool = function(value) {
  return toString(value) === '[object Boolean]';
};

// node_modules/es-is/infinite.js
// Generated by CoffeeScript 1.12.5
var isInfinite;

var isInfinite$1 = isInfinite = function(value) {
  return value === 2e308 || value === -2e308;
};

// node_modules/es-is/number.js
// Generated by CoffeeScript 1.12.5
var isNumber;

var isNumber$1 = isNumber = function(value) {
  return toString(value) === '[object Number]';
};

// node_modules/es-is/array-like.js
// Generated by CoffeeScript 1.12.5
var isArrayLike;

var isArrayLike$1 = isArrayLike = function(value) {
  return !!value && !isBool$1(value) && hasOwn(value, 'length') && isFinite(value.length) && isNumber$1(value.length) && value.length >= 0;
};

// node_modules/es-is/array.js
// Generated by CoffeeScript 1.12.5
var isArray;

var isArray$1 = isArray = Array.isArray || function(value) {
  return toString(value) === '[object Array]';
};

// node_modules/es-is/function.js
// Generated by CoffeeScript 1.12.5
var isFunction;

var isFunction$1 = isFunction = function(value) {
  var str;
  if (typeof window !== 'undefined' && value === window.alert) {
    return true;
  }
  str = toString(value);
  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';
};

// node_modules/es-is/object.js
// Generated by CoffeeScript 1.12.5
var isObject;

var isObject$1 = isObject = function(value) {
  return toString(value) === '[object Object]';
};

// node_modules/es-is/arguments.js
// Generated by CoffeeScript 1.12.5
var isArguments;

var isArguments$1 = isArguments = function(value) {
  var isOldArguments, isStandardArguments;
  isStandardArguments = toString(value) === '[object Arguments]';
  isOldArguments = !isArray$1(value) && isArrayLike$1(value) && isObject$1(value) && isFunction$1(value.callee);
  return isStandardArguments || isOldArguments;
};

// node_modules/es-is/async-function.js
// Generated by CoffeeScript 1.12.5
var isAsyncFunction;

isAsyncFunction = function(value) {
  return toString(value) === '[object AsyncFunction]';
};

// node_modules/es-is/string.js
// Generated by CoffeeScript 1.12.5
var isString;

var isString$1 = isString = function(value) {
  return toString(value) === '[object String]';
};

// node_modules/es-is/base64.js
// Generated by CoffeeScript 1.12.5
var base64Regex;
var isBase64;

base64Regex = /^([A-Za-z0-9+\/]{4})*([A-Za-z0-9+\/]{4}|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{2}==)$/;

isBase64 = function(value) {
  return isString$1(value) && (!value.length || base64Regex.test(value));
};

// node_modules/es-is/date.js
// Generated by CoffeeScript 1.12.5
var isDate;

var isDate$1 = isDate = function(value) {
  return toString(value) === '[object Date]';
};

// node_modules/es-is/utils.js
// Generated by CoffeeScript 1.12.5
var isActualNaN = function(value) {
  return value !== value;
};

// node_modules/es-is/decimal.js
// Generated by CoffeeScript 1.12.5
var isDecimal;

isDecimal = function(value) {
  return isNumber$1(value) && !isActualNaN(value) && !isInfinite$1(value) && value % 1 !== 0;
};

// node_modules/es-is/defined.js
// Generated by CoffeeScript 1.12.5
var isDefined;

isDefined = function(value) {
  return typeof value !== 'undefined';
};

// node_modules/es-is/divisible-by.js
// Generated by CoffeeScript 1.12.5
var isDivisibleBy;

isDivisibleBy = function(value, n) {
  var isDividendInfinite, isDivisorInfinite, isNonZeroNumber;
  isDividendInfinite = isInfinite$1(value);
  isDivisorInfinite = isInfinite$1(n);
  isNonZeroNumber = isNumber$1(value) && !isActualNaN(value) && isNumber$1(n) && !isActualNaN(n) && n !== 0;
  return isDividendInfinite || isDivisorInfinite || isNonZeroNumber && value % n === 0;
};

// node_modules/es-is/element.js
// Generated by CoffeeScript 1.12.5
var isElement;

isElement = function(value) {
  return value !== void 0 && typeof HTMLElement !== 'undefined' && value instanceof HTMLElement && value.nodeType === 1;
};

// node_modules/es-is/empty-arguments.js
// Generated by CoffeeScript 1.12.5
var isEmptyArguments;

isEmptyArguments = function(value) {
  return isArguments$1(value) && value.length === 0;
};

// node_modules/es-is/empty-array.js
// Generated by CoffeeScript 1.12.5
var isEmptyArray;

isEmptyArray = function(value) {
  return isArray$1(value) && value.length === 0;
};

// node_modules/es-is/empty.js
// Generated by CoffeeScript 1.12.5
var isEmpty;

isEmpty = function(value) {
  var key, type;
  type = toString(value);
  if (type === '[object Array]' || type === '[object Arguments]' || type === '[object String]') {
    return value.length === 0;
  }
  if (type === '[object Object]') {
    for (key in value) {
      if (hasOwn(value, key)) {
        return false;
      }
    }
    return true;
  }
  return !value;
};

// node_modules/es-is/equal.js
// Generated by CoffeeScript 1.12.5
var isEqual;

isEqual = function(value, other) {
  var key, type;
  if (value === other) {
    return true;
  }
  type = toString(value);
  if (type !== toString(other)) {
    return false;
  }
  if (type === '[object Object]') {
    for (key in value) {
      if (!isEqual(value[key], other[key]) || !(key in other)) {
        return false;
      }
    }
    for (key in other) {
      if (!isEqual(value[key], other[key]) || !(key in value)) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Array]') {
    key = value.length;
    if (key !== other.length) {
      return false;
    }
    while (key--) {
      if (!isEqual(value[key], other[key])) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Function]') {
    return value.prototype === other.prototype;
  }
  if (type === '[object Date]') {
    return value.getTime() === other.getTime();
  }
  return false;
};

// node_modules/es-is/error.js
// Generated by CoffeeScript 1.12.5
var isError;

isError = function(value) {
  return toString(value) === '[object Error]';
};

// node_modules/es-is/even.js
// Generated by CoffeeScript 1.12.5
var isEven;

isEven = function(value) {
  return isInfinite$1(value) || isNumber$1(value) && value === value && value % 2 === 0;
};

// node_modules/es-is/false.js
// Generated by CoffeeScript 1.12.5
var isFalse;

isFalse = function(value) {
  return isBool$1(value) && Boolean(Number(value)) === false;
};

// node_modules/es-is/generator-function.js
// Generated by CoffeeScript 1.12.5
var isGeneratorFunction;

isGeneratorFunction = function(value) {
  return toString(value) === '[object GeneratorFunction]';
};

// node_modules/es-is/generator.js
// Generated by CoffeeScript 1.12.5
var isGenerator;

isGenerator = function(value) {
  return (isFunction$1(typeof g !== "undefined" && g !== null ? g.next : void 0)) && (isFunction$1(g["throw"]));
};

// node_modules/es-is/ge.js
// Generated by CoffeeScript 1.12.5
var isGe;

isGe = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value >= other;
};

// node_modules/es-is/gt.js
// Generated by CoffeeScript 1.12.5
var isGt;

isGt = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value > other;
};

// node_modules/es-is/hash.js
// Generated by CoffeeScript 1.12.5
var isHash;

isHash = function(value) {
  return isObject$1(value) && value.constructor === Object && !value.nodeType && !value.setInterval;
};

// node_modules/es-is/hex.js
// Generated by CoffeeScript 1.12.5
var hexRegex;
var isHex;

hexRegex = /^[A-Fa-f0-9]+$/;

isHex = function(value) {
  return isString$1(value) && (!value.length || hexRegex.test(value));
};

// node_modules/es-is/hosted.js
// Generated by CoffeeScript 1.12.5
var NON_HOST_TYPES;
var isHosted;

NON_HOST_TYPES = {
  'boolean': 1,
  number: 1,
  string: 1,
  undefined: 1
};

isHosted = function(value, host) {
  var type;
  type = typeof host[value];
  if (type === 'object') {
    return !!host[value];
  } else {
    return !NON_HOST_TYPES[type];
  }
};

// node_modules/es-is/instanceof.js
// Generated by CoffeeScript 1.12.5
var isInstanceOf;

isInstanceOf = function(value, constructor) {
  return value instanceof constructor;
};

// node_modules/es-is/integer.js
// Generated by CoffeeScript 1.12.5
var isInteger;

isInteger = function(value) {
  return isNumber$1(value) && !isActualNaN(value) && value % 1 === 0;
};

// node_modules/es-is/le.js
// Generated by CoffeeScript 1.12.5
var isLe;

isLe = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value <= other;
};

// node_modules/es-is/lt.js
// Generated by CoffeeScript 1.12.5
var isLt;

isLt = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value < other;
};

// node_modules/es-is/max.js
// Generated by CoffeeScript 1.12.5
var isMax;

isMax = function(value, others) {
  var len;
  if (isActualNaN(value)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isArrayLike$1(others)) {
    throw new TypeError('second argument must be array-like');
  }
  len = others.length;
  while (--len >= 0) {
    if (value < others[len]) {
      return false;
    }
  }
  return true;
};

// node_modules/es-is/min.js
// Generated by CoffeeScript 1.12.5
var isMin;

isMin = function(value, others) {
  var len;
  if (isActualNaN(value)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isArrayLike$1(others)) {
    throw new TypeError('second argument must be array-like');
  }
  len = others.length;
  while (--len >= 0) {
    if (value > others[len]) {
      return false;
    }
  }
  return true;
};

// node_modules/es-is/nan.js
// Generated by CoffeeScript 1.12.5
var isNaN$1;

isNaN$1 = function(value) {
  return !isNumber$1(value) || value !== value;
};

// node_modules/es-is/null.js
// Generated by CoffeeScript 1.12.5
var isNull;

isNull = function(value) {
  return value === null;
};

// node_modules/es-is/odd.js
// Generated by CoffeeScript 1.12.5
var isOdd;

isOdd = function(value) {
  return isInfinite$1(value) || isNumber$1(value) && value === value && value % 2 !== 0;
};

// node_modules/es-is/primitive.js
// Generated by CoffeeScript 1.12.5
var isPrimitive;

isPrimitive = function(value) {
  if (!value) {
    return true;
  }
  if (typeof value === 'object' || isObject$1(value) || isFunction$1(value) || isArray$1(value)) {
    return false;
  }
  return true;
};

// node_modules/es-is/promise.js
// Generated by CoffeeScript 1.12.5
var isPromise;

var isPromise$1 = isPromise = function(value) {
  return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
};

// node_modules/es-is/regexp.js
// Generated by CoffeeScript 1.12.5
var isRegExp;

isRegExp = function(value) {
  return toString(value) === '[object RegExp]';
};

// node_modules/es-is/symbol.js
// Generated by CoffeeScript 1.12.5
var isSymbol;
var symbolValueOf;

symbolValueOf = typeof Symbol === 'function' ? Symbol.prototype.valueOf : void 0;

isSymbol = function(value) {
  return typeof Symbol === 'function' && toString(value) === '[object Symbol]' && typeof symbolValueOf.call(value) === 'symbol';
};

// node_modules/es-is/true.js
// Generated by CoffeeScript 1.12.5
var isTrue;

isTrue = function(value) {
  return isBool$1(value) && Boolean(Number(value)) === true;
};

// node_modules/es-is/type.js
// Generated by CoffeeScript 1.12.5
var isType;

isType = function(value, type) {
  return typeof value === type;
};

// node_modules/es-is/undefined.js
// Generated by CoffeeScript 1.12.5
var isUndefined;

isUndefined = function(value) {
  return typeof value === 'undefined';
};

// node_modules/es-is/valid-date.js
// Generated by CoffeeScript 1.12.5
var isValidDate;

isValidDate = function(value) {
  return isDate$1(value) && !isNaN(Number(value));
};

// node_modules/es-is/within.js
// Generated by CoffeeScript 1.12.5
var isWithin;

isWithin = function(value, start, finish) {
  var isAnyInfinite;
  if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isNumber$1(value) || !isNumber$1(start) || !isNumber$1(finish)) {
    throw new TypeError('all arguments must be numbers');
  }
  isAnyInfinite = isInfinite$1(value) || isInfinite$1(start) || isInfinite$1(finish);
  return isAnyInfinite || value >= start && value <= finish;
};

// node_modules/es-is/index.mjs
// Generated by CoffeeScript 1.12.5

// src/spawn/buffer-stream.coffee
var BufferStream;
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
var hasProp = {}.hasOwnProperty;

BufferStream = (function(superClass) {
  extend(BufferStream, superClass);

  function BufferStream() {
    BufferStream.__super__.constructor.call(this);
    this.buffer = '';
    this.writable = true;
  }

  BufferStream.prototype.write = function(data) {
    return this.buffer += data;
  };

  BufferStream.prototype.end = function(data) {
    if (arguments.length) {
      this.write(data);
    }
    return this.writable = false;
  };

  BufferStream.prototype.destroy = function() {
    return this.writable = false;
  };

  BufferStream.prototype.toString = function() {
    return this.buffer;
  };

  return BufferStream;

})(Stream);

var BufferStream$1 = BufferStream;

// node_modules/jsonify/lib/parse.js
var at;
var ch;
var escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    };
var text;
var error$1 = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    };
var next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error$1("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    };
var number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error$1("Bad number");
        } else {
            return number;
        }
    };
var string$1 = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error$1("Bad string");
    };
var white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    };
var word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error$1("Unexpected '" + ch + "'");
    };
var value;
var array$1 = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error$1("Bad array");
    };
var object$1 = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string$1();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error$1('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error$1("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object$1();
    case '[':
        return array$1();
    case '"':
        return string$1();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

var parse$4 = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error$1("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

// node_modules/jsonify/lib/stringify.js
var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
var gap;
var indent;
var meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    };
var rep;

function quote$1(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote$1(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote$1(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote$1(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

var stringify$1 = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/jsonify/lib/parse.js

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/jsonify/lib/stringify.js

// node_modules/jsonify/index.js
var parse$3 = parse$4;
var stringify = stringify$1;

var index$1 = {
	parse: parse$3,
	stringify: stringify
};

// node_modules/array-map/index.js
var index$3 = function (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = xs[i];
        if (hasOwn$1.call(xs, i)) res.push(f(x, i, xs));
    }
    return res;
};

var hasOwn$1 = Object.prototype.hasOwnProperty;

// node_modules/array-filter/index.js
/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @return {Array}
 */

var index$5 = function (arr, fn) {
  if (arr.filter) return arr.filter(fn);
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn$2.call(arr, i)) continue;
    if (fn(arr[i], i, arr)) ret.push(arr[i]);
  }
  return ret;
};

var hasOwn$2 = Object.prototype.hasOwnProperty;

// node_modules/array-reduce/index.js
var hasOwn$3 = Object.prototype.hasOwnProperty;

var index$7 = function (xs, f, acc) {
    var hasAcc = arguments.length >= 3;
    if (hasAcc && xs.reduce) return xs.reduce(f, acc);
    if (xs.reduce) return xs.reduce(f);
    
    for (var i = 0; i < xs.length; i++) {
        if (!hasOwn$3.call(xs, i)) continue;
        if (!hasAcc) {
            acc = xs[i];
            hasAcc = true;
            continue;
        }
        acc = f(acc, xs[i], i);
    }
    return acc;
};

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/jsonify/index.js

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/array-map/index.js

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/array-filter/index.js

//  commonjs-proxy:/Users/zk/dev/zeekay/executive/node_modules/array-reduce/index.js

// node_modules/shell-quote/index.js
var json = typeof JSON !== undefined ? JSON : index$1;




var quote = function (xs) {
    return index$3(xs, function (s) {
        if (s && typeof s === 'object') {
            return s.op.replace(/(.)/g, '\\$1');
        }
        else if (/["\s]/.test(s) && !/'/.test(s)) {
            return "'" + s.replace(/(['\\])/g, '\\$1') + "'";
        }
        else if (/["'\s]/.test(s)) {
            return '"' + s.replace(/(["\\$`!])/g, '\\$1') + '"';
        }
        else {
            return String(s).replace(/([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, '\\$1'); 
        }
    }).join(' ');
};

var CONTROL = '(?:' + [
    '\\|\\|', '\\&\\&', ';;', '\\|\\&', '[&;()|<>]'
].join('|') + ')';
var META = '|&;()<> \\t';
var BAREWORD = '(\\\\[\'"' + META + ']|[^\\s\'"' + META + '])+';
var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
var DOUBLE_QUOTE = '\'((\\\\\'|[^\'])*?)\'';

var TOKEN = '';
for (var i = 0; i < 4; i++) {
    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);
}

var parse_1 = function (s, env, opts) {
    var mapped = parse$2(s, env, opts);
    if (typeof env !== 'function') return mapped;
    return index$7(mapped, function (acc, s) {
        if (typeof s === 'object') return acc.concat(s);
        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));
        if (xs.length === 1) return acc.concat(xs[0]);
        return acc.concat(index$3(index$5(xs, Boolean), function (x) {
            if (RegExp('^' + TOKEN).test(x)) {
                return json.parse(x.split(TOKEN)[1]);
            }
            else return x;
        }));
    }, []);
};

function parse$2 (s, env, opts) {
    var chunker = new RegExp([
        '(' + CONTROL + ')', // control chars
        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'
    ].join('|'), 'g');
    var match = index$5(s.match(chunker), Boolean);
    var commented = false;

    if (!match) return [];
    if (!env) env = {};
    if (!opts) opts = {};
    return index$3(match, function (s, j) {
        if (commented) {
            return;
        }
        if (RegExp('^' + CONTROL + '$').test(s)) {
            return { op: s };
        }

        // Hand-written scanner/parser for Bash quoting rules:
        //
        //  1. inside single quotes, all characters are printed literally.
        //  2. inside double quotes, all characters are printed literally
        //     except variables prefixed by '$' and backslashes followed by
        //     either a double quote or another backslash.
        //  3. outside of any quotes, backslashes are treated as escape
        //     characters and not printed (unless they are themselves escaped)
        //  4. quote context can switch mid-token if there is no whitespace
        //     between the two quote contexts (e.g. all'one'"token" parses as
        //     "allonetoken")
        var SQ = "'";
        var DQ = '"';
        var DS = '$';
        var BS = opts.escape || '\\';
        var quote = false;
        var esc = false;
        var out = '';
        var isGlob = false;

        for (var i = 0, len = s.length; i < len; i++) {
            var c = s.charAt(i);
            isGlob = isGlob || (!quote && (c === '*' || c === '?'));
            if (esc) {
                out += c;
                esc = false;
            }
            else if (quote) {
                if (c === quote) {
                    quote = false;
                }
                else if (quote == SQ) {
                    out += c;
                }
                else { // Double quote
                    if (c === BS) {
                        i += 1;
                        c = s.charAt(i);
                        if (c === DQ || c === BS || c === DS) {
                            out += c;
                        } else {
                            out += BS + c;
                        }
                    }
                    else if (c === DS) {
                        out += parseEnvVar();
                    }
                    else {
                        out += c;
                    }
                }
            }
            else if (c === DQ || c === SQ) {
                quote = c;
            }
            else if (RegExp('^' + CONTROL + '$').test(c)) {
                return { op: s };
            }
            else if (RegExp('^#$').test(c)) {
                commented = true;
                if (out.length){
                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];
                }
                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];
            }
            else if (c === BS) {
                esc = true;
            }
            else if (c === DS) {
                out += parseEnvVar();
            }
            else out += c;
        }

        if (isGlob) return {op: 'glob', pattern: out};

        return out;

        function parseEnvVar() {
            i += 1;
            var varend, varname;
            //debugger
            if (s.charAt(i) === '{') {
                i += 1;
                if (s.charAt(i) === '}') {
                    throw new Error("Bad substitution: " + s.substr(i - 2, 3));
                }
                varend = s.indexOf('}', i);
                if (varend < 0) {
                    throw new Error("Bad substitution: " + s.substr(i));
                }
                varname = s.substr(i, varend - i);
                i = varend;
            }
            else if (/[*@#?$!_\-]/.test(s.charAt(i))) {
                varname = s.charAt(i);
                i += 1;
            }
            else {
                varend = s.substr(i).match(/[^\w\d_]/);
                if (!varend) {
                    varname = s.substr(i);
                    i = s.length;
                } else {
                    varname = s.substr(i, varend.index);
                    i += varend.index - 1;
                }
            }
            return getVar(null, '', varname);
        }
    })
    // finalize parsed aruments
    .reduce(function(prev, arg){
        if (arg === undefined){
            return prev;
        }
        return prev.concat(arg);
    },[]);

    function getVar (_, pre, key) {
        var r = typeof env === 'function' ? env(key) : env[key];
        if (r === undefined) r = '';

        if (typeof r === 'object') {
            return pre + TOKEN + json.stringify(r) + TOKEN;
        }
        else return pre + r;
    }
}

var index = {
	quote: quote,
	parse: parse_1
};

// src/spawn/shell-builtins.coffee
var shellBuiltins;

var builtins = shellBuiltins = {
  ':': true,
  '.': true,
  "break": true,
  cd: true,
  "continue": true,
  "eval": true,
  exec: true,
  exit: true,
  "export": true,
  getopts: true,
  hash: true,
  pwd: true,
  readonly: true,
  "return": true,
  shift: true,
  test: true,
  times: true,
  trap: true,
  umask: true,
  unset: true,
  alias: true,
  bind: true,
  builtin: true,
  caller: true,
  command: true,
  declare: true,
  echo: true,
  enable: true,
  help: true,
  "let": true,
  local: true,
  logout: true,
  mapfile: true,
  printf: true,
  read: true,
  readarray: true,
  source: true,
  type: true,
  typeset: true,
  ulimit: true,
  unalias: true
};

// src/spawn/parse.coffee
var isWin;
var parse$$1;
var parseObject;
var parseShell;
var parseString;
var shellRequired;
var unShellQuote;
var winHacks;

isWin = /^win/.test(process.platform);

unShellQuote = function(args) {
  var a, args_, i, len;
  args_ = [];
  for (i = 0, len = args.length; i < len; i++) {
    a = args[i];
    if (isString$1(a)) {
      args_.push(a);
    } else {
      if (a.op === 'glob') {
        args_.push(a.pattern);
      } else {
        args_.push(a.op);
      }
    }
  }
  return args_;
};

parseShell = function(s, env, first) {
  var args, cmd, foundEnv, k, ref, v;
  if (first == null) {
    first = true;
  }
  args = index.parse(s, env);
  cmd = args.shift();
  while (~cmd.indexOf('=')) {
    foundEnv = true;
    ref = cmd.split('=', 2), k = ref[0], v = ref[1];
    env[k] = v;
    cmd = args.shift();
  }
  if (first && foundEnv) {
    return parseShell(s, env, false);
  }
  return [cmd, args, env];
};

parseString = function(s, opts) {
  var args, cmd, env, ref;
  env = Object.assign({}, process.env, opts.env);
  return ref = parseShell(s, env), cmd = ref[0], args = ref[1], env = ref[2], ref;
};

parseObject = function(obj, opts) {
  var args, cmd, env, ref;
  cmd = obj.cmd;
  args = (ref = obj.args) != null ? ref : [];
  env = Object.assign({}, process.env, opts.env, obj.env);
  return [cmd, args, env];
};

shellRequired = function(cmd, args) {
  var arg, i, len;
  if (builtins[cmd]) {
    return true;
  }
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    if (!isString$1(arg)) {
      return true;
    }
  }
  return false;
};

winHacks = function(cmd, args) {
  var cmdfile;
  cmd = path.normalize(cmd);
  cmdfile = cmd + '.cmd';
  if (fs.existsSync(cmdfile)) {
    cmd = cmdfile;
  }
  args = ['/c', cmd].concat(args);
  cmd = 'cmd.exe';
  return [cmd, args];
};

var parse$1 = parse$$1 = function(cmdArgs, opts) {
  var args, cmd, env, ref, ref1, ref2;
  if (opts == null) {
    opts = {};
  }
  if (isString$1(cmdArgs)) {
    ref = parseString(cmdArgs, opts), cmd = ref[0], args = ref[1], env = ref[2];
  } else if (isObject$1(cmdArgs)) {
    ref1 = parseObject(cmdArgs, opts), cmd = ref1[0], args = ref1[1], env = ref1[2];
  } else {
    throw new Error("Unable to parse command '" + cmdArgs + "'");
  }
  if (shellRequired(cmd, args)) {
    if (opts.shell == null) {
      opts.shell = true;
    }
    args = unShellQuote(args);
  }
  if (isWin) {
    ref2 = winHacks(cmd, args), cmd = ref2[0], args = ref2[1];
  }
  return [cmd, args, opts];
};

// src/utils.coffee
var logError = function(err) {
  if ((err.code === 'ENOENT') && /^spawn/.test(err.syscall)) {
    console.error("Error: " + err.code + ", " + err.syscall);
    return console.error("Make sure '" + err.cmd + "' exists and is executable.");
  }
};

var once = function(fn) {
  var ran, result;
  ran = false;
  result = null;
  return function() {
    if (ran) {
      return result;
    }
    ran = true;
    result = fn.apply(this, arguments);
    fn = null;
    return result;
  };
};

var mergeResult = function(stdout, stderr, status, object) {
  var ret;
  ret = object != null ? object : {};
  if (ret.status == null) {
    ret.status = status;
  }
  if (ret.stderr == null) {
    ret.stderr = stderr;
  }
  if (ret.stdout == null) {
    ret.stdout = stdout;
  }
  return ret;
};

// src/spawn/async.coffee
var async$1;

var async$2 = async$1 = function(cmd, opts, cb) {
  var args, child, done, exit, ref, ref1, ref2, ref3, stderr, stdout;
  ref = parse$1(cmd, opts), cmd = ref[0], args = ref[1], opts = ref[2];
  stderr = new BufferStream$1();
  stdout = new BufferStream$1();
  child = child_process.spawn(cmd, args, {
    cwd: opts.cwd,
    env: opts.env,
    argv0: opts.argv0,
    stdio: (ref1 = opts.stdio) != null ? ref1 : [0, 'pipe', 'pipe'],
    detached: opts.detached,
    uid: opts.uid,
    gid: opts.gid,
    shell: opts.shell
  });
  child.setMaxListeners(0);
  child.stdout.setEncoding((ref2 = opts.encoding) != null ? ref2 : 'utf8');
  child.stderr.setEncoding((ref3 = opts.encoding) != null ? ref3 : 'utf8');
  if (!opts.interactive) {
    child.stdout.pipe(stdout);
    child.stderr.pipe(stderr);
  }
  if (!opts.quiet) {
    child.stdout.pipe(process.stdout);
    child.stderr.pipe(process.stderr);
  }
  done = once(function(err, status) {
    stdout.destroy();
    stderr.destroy();
    child.kill();
    stdout = stdout.toString();
    stderr = stderr.toString();
    if (err != null) {
      err.cmd = cmd;
      err.args = args;
      err.stdout = stdout;
      err.stderr = stderr;
      err.status = status;
      if (!opts.quiet) {
        logError(err);
      }
    }
    return cb(err, stdout, stderr, status);
  });
  exit = once(function(status, signal) {
    var err;
    err = null;
    if (status !== 0) {
      err = new Error("Command failed, '" + cmd + "' exited with status " + status);
      err.signal = signal;
    }
    return done(err, status);
  });
  child.on('close', exit);
  child.on('error', done);
  return child;
};

// src/spawn/sync.coffee
var sync$1;

var sync$2 = sync$1 = function(cmd, opts, cb) {
  var args, error, output, pid, ref, ref1, ref2, ref3, signal, status, stderr, stdout;
  ref = parse$1(cmd, opts), cmd = ref[0], args = ref[1], opts = ref[2];
  ref3 = child_process.spawnSync(cmd, args, {
    cwd: opts.cwd,
    input: opts.input,
    stdio: (ref1 = opts.stdio) != null ? ref1 : [0, 'pipe', 'pipe'],
    env: opts.env,
    uid: opts.uid,
    gid: opts.gid,
    timeout: opts.timeout,
    killSignal: opts.killSignal,
    maxBuffer: opts.maxBuffer,
    encoding: (ref2 = opts.encoding) != null ? ref2 : 'utf8'
  }), pid = ref3.pid, output = ref3.output, stdout = ref3.stdout, stderr = ref3.stderr, status = ref3.status, signal = ref3.signal, error = ref3.error;
  opts;
  if (!opts.quiet) {
    process.stdout.write(stdout);
    process.stderr.write(stderr);
  }
  if ((error == null) && status !== 0) {
    error = new Error("Command failed, '" + cmd + "' exited with status " + status);
  }
  if (error != null) {
    error.status = status;
    error.pid = pid;
    error.signal = signal;
    error.stderr = stderr;
    error.stdout = stdout;
    if (!opts.quiet) {
      logError(error);
    }
  }
  cb(error, stdout, stderr, status);
  return {
    status: status,
    stderr: stderr,
    stdout: stdout,
    error: error
  };
};

// src/flow/parallel.coffee
var parallel;

var parallel$1 = parallel = function(fn, cmds, opts, cb) {
  var append, cmd, done, errAll, errors, object, outAll, todo;
  outAll = '';
  errAll = '';
  errors = [];
  todo = cmds.length;
  if (cmds.length && isArray$1(cmds[0])) {
    object = {};
  } else {
    object = null;
  }
  append = function(key, res) {
    var error, status, stderr, stdout;
    if (res == null) {
      res = {};
    }
    error = res.error, stdout = res.stdout, stderr = res.stderr, status = res.status;
    if (stdout != null) {
      outAll += stdout;
    }
    if (stderr != null) {
      errAll += stderr;
    }
    if (status != null) {
      status;
    } else {
      0;
    }
    if (key != null) {
      return object[key] = {
        error: error,
        stdout: stdout,
        stderr: stderr,
        status: status
      };
    }
  };
  done = function(err, status) {
    if (status == null) {
      status = 0;
    }
    if (err != null) {
      if (!opts.quiet) {
        console.error(err.toString());
      }
      errors.push(err);
    }
    if (--todo) {
      return;
    }
    if (errors.length) {
      err = new Error('Partial completion');
      err.errors = errors;
      status = 1;
    }
    return cb(err, outAll, errAll, status, object);
  };
  while (cmds.length) {
    cmd = cmds.shift();
    (function(cmd) {
      var err, key, ref, val;
      if (isArray$1(cmd)) {
        ref = cmd, key = ref[0], cmd = ref[1];
      }
      if (isString$1(cmd)) {
        return fn(cmd, opts, function(err, stdout, stderr, status) {
          append(key, {
            error: err,
            stdout: stdout,
            stderr: stderr,
            status: status
          });
          return done(err, status);
        });
      } else if (isFunction$1(cmd)) {
        try {
          val = cmd();
          if (isPromise$1(val)) {
            return cmds.push(val);
          } else if (isString$1(val)) {
            return cmds.push(val);
          } else {
            append(key, val);
            return done(null, 0);
          }
        } catch (error1) {
          err = error1;
          return done(err);
        }
      } else if (isPromise$1(cmd)) {
        return cmd.then(function(val) {
          append(key, val);
          return done(null, 0);
        })["catch"](function(err) {
          return done(err);
        });
      }
    })(cmd);
  }
};

// src/flow/serial.coffee
var serial;

var serial$1 = serial = function(fn, cmds, opts, cb) {
  var append, errAll, lastStatus, next, object, outAll;
  errAll = '';
  outAll = '';
  lastStatus = null;
  if (cmds.length && isArray$1(cmds[0])) {
    object = {};
  } else {
    object = null;
  }
  append = function(key, res) {
    var error, status, stderr, stdout;
    if (res == null) {
      res = {};
    }
    error = res.error, stdout = res.stdout, stderr = res.stderr, status = res.status;
    if (stdout != null) {
      outAll += stdout;
    }
    if (stderr != null) {
      errAll += stderr;
    }
    if (status != null) {
      lastStatus = status;
    } else {
      lastStatus = 0;
    }
    if (key != null) {
      return object[key] = {
        error: error,
        stdout: stdout,
        stderr: stderr,
        status: status
      };
    }
  };
  return (next = function() {
    var cmd, err, key, ref, val;
    if (!cmds.length) {
      return cb(null, outAll, errAll, lastStatus, object);
    }
    cmd = cmds.shift();
    if (isArray$1(cmd)) {
      ref = cmd, key = ref[0], cmd = ref[1];
    }
    if (isString$1(cmd)) {
      return fn(cmd, opts, function(err, stdout, stderr, status) {
        append(key, {
          error: err,
          stdout: stdout,
          stderr: stderr,
          status: status
        });
        if (opts.strict && (err != null)) {
          return cb(err, outAll, errAll, lastStatus, object);
        } else {
          return next();
        }
      });
    } else if (isPromise$1(cmd)) {
      return cmd.then(function(val) {
        append(key, val);
        return next();
      })["catch"](function(err) {
        return cb(err, outAll, errAll, 1, object);
      });
    } else if (isFunction$1(cmd)) {
      try {
        val = cmd();
        if ((isPromise$1(val)) || (isString$1(val))) {
          cmds.unshift(val);
        } else {
          append(key, val);
        }
        return next();
      } catch (error1) {
        err = error1;
        return cb(err, outAll, errAll, 1, object);
      }
    } else {
      return cb(new Error("Not a valid command: " + (cmd.toString())));
    }
  })();
};

// src/flow/index.coffee
var array;
var object;
var string;

array = function(exec, cmds, opts, cb) {
  if (opts.parallel) {
    return parallel$1(exec, cmds, opts, cb);
  } else {
    return serial$1(exec, cmds, opts, cb);
  }
};

string = function(exec, str, opts, cb) {
  var cmds, s;
  cmds = (function() {
    var i, len, ref, results;
    ref = str.split('\n');
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      s = ref[i];
      if (s.trim() !== '') {
        results.push(s);
      }
    }
    return results;
  })();
  return array(exec, cmds, opts, cb);
};

object = function(exec, obj, opts, cb) {
  var cmd, cmds, k;
  cmds = (function() {
    var results;
    results = [];
    for (k in obj) {
      cmd = obj[k];
      results.push([k, cmd]);
    }
    return results;
  })();
  return array(exec, cmds, opts, cb);
};

var flow = function(cmds, opts, cb) {
  var exec;
  exec = opts.sync ? sync$2 : async$2;
  if (isString$1(cmds)) {
    return string(exec, cmds, opts, cb);
  }
  if (isObject$1(cmds)) {
    return object(exec, cmds, opts, cb);
  }
  if (isArray$1(cmds)) {
    return array(exec, cmds, opts, cb);
  }
  throw new Error("Unable to return results for cmds = " + (JSON.stringify(cmds)));
};

// src/executive.coffee
var async;
var promise;
var sync;

async = function(cmds, opts, cb) {
  return flow(cmds, opts, function(err, stdout, stderr, status, object) {
    var obj;
    if (object != null) {
      obj = mergeResult(stdout, stderr, status, object);
      return cb(err, obj, stdout, stderr, status);
    } else {
      return cb(err, stdout, stderr, status);
    }
  });
};

sync = function(cmds, opts) {
  var ret;
  ret = null;
  flow(cmds, opts, function(err, stdout, stderr, status, object) {
    if (opts.syncThrows) {
      if (opts.strict && status !== 0) {
        throw err;
      } else if ((err != null) && (status == null)) {
        throw err;
      }
    }
    return ret = mergeResult(stdout, stderr, status, object);
  });
  return ret;
};

promise = function(cmds, opts) {
  return new Promise(function(resolve, reject) {
    return flow(cmds, opts, function(err, stdout, stderr, status, object) {
      if (opts.strict && status !== 0) {
        return reject(err);
      } else if ((err != null) && (status == null)) {
        return reject(err);
      }
      return resolve(mergeResult(stdout, stderr, status, object));
    });
  });
};

var exec$1 = function(cmds, opts, cb) {
  var ref;
  if (isFunction$1(opts)) {
    ref = [opts, {}], cb = ref[0], opts = ref[1];
  }
  if (opts == null) {
    opts = {};
  }
  if (isFunction$1(cb)) {
    return async(cmds, opts, cb);
  }
  if (opts.sync) {
    return sync(cmds, opts);
  }
  return promise(cmds, opts);
};

// src/index.coffee
var partial;

partial = function(defaults) {
  return function(cmds, opts, cb) {
    var ref;
    if (isFunction$1(opts)) {
      ref = [opts, {}], cb = ref[0], opts = ref[1];
    }
    return exec$1(cmds, Object.assign({}, defaults, opts), cb);
  };
};

exec$1.interactive = partial({
  interactive: true
});

exec$1.parallel = partial({
  parallel: true
});

exec$1.quiet = partial({
  quiet: true
});

exec$1.serial = partial({
  parallel: false
});

exec$1.strict = partial({
  strict: true
});

exec$1.sync = partial({
  sync: true
});

module.exports = exec$1;
//# sourceMappingURL=executive.js.map
