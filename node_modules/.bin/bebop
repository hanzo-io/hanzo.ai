#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var exec = _interopDefault(require('executive'));
var fs = _interopDefault(require('fs'));
var os = _interopDefault(require('os'));
var vigil = _interopDefault(require('vigil'));
var basicAuth = _interopDefault(require('basic-auth-connect'));
var connect = _interopDefault(require('connect'));
var favicons = _interopDefault(require('connect-favicons'));
var http = _interopDefault(require('http'));
var logger = _interopDefault(require('morgan'));
var path = _interopDefault(require('path'));
var serveIndex = _interopDefault(require('serve-index'));
var serveStatic = _interopDefault(require('serve-static'));
var url = require('url');
var url__default = _interopDefault(url);
var colors = _interopDefault(require('colors/safe'));
var marked = _interopDefault(require('marked'));
var ws = _interopDefault(require('ws'));

// src/log.coffee
var _;
var fn;
var log;
var method;
var prettyError;
var prettyJSON;
var theme;

theme = {
  debug: 'blue',
  info: 'white',
  warn: 'yellow',
  error: 'red',
  bebop: 'black',
  modified: 'cyan',
  compiled: 'blue'
};

colors.setTheme(theme);

prettyJSON = function(obj) {
  return JSON.stringify(obj, null, 2);
};

prettyError = function(err) {
  var msg, std;
  std = [];
  if (err.stdout != null) {
    std.push(err.stdout);
  }
  if (err.stderr != null) {
    std.push(err.stderr);
  }
  if (std.length > 0) {
    return std.join('\n');
  } else {
    msg = err.stack;
    return msg = msg.replace(/^Error: /, '');
  }
};

log = function() {
  if (root.console == null) {
    return console.log.apply(console, arguments);
  }
};

fn = function(method) {
  var prefix;
  prefix = colors[method](method + ' ');
  return log[method] = function(msg, extra) {
    var err;
    err = null;
    switch (typeof msg) {
      case 'string':
        msg = msg;
        break;
      case 'object':
        if (msg instanceof Error) {
          msg = prettyError(msg);
        } else {
          msg = '\n' + prettyJSON(msg);
        }
    }
    if (extra instanceof Error) {
      extra = prettyError(extra);
    } else {
      extra = prettyJSON(extra);
    }
    if (extra != null) {
      msg = msg + '\n' + extra;
    }
    msg = prefix + msg;
    if (err != null) {
      return console.error(msg);
    } else {
      return console.log(msg);
    }
  };
};
for (method in theme) {
  _ = theme[method];
  fn(method);
}

var log$1 = log;

// src/middleware/fake-express.coffee
var fakeExpress = function(req, res, next) {
  var url$$1;
  res.redirect = function(loc) {
    res.writeHead(302, {
      Location: loc
    });
    return res.end();
  };
  res.set = function(headers) {
    var k, results, v;
    results = [];
    for (k in headers) {
      v = headers[k];
      results.push(res.setHeader(k, v));
    }
    return results;
  };
  res.send = function(body) {
    return res.end(body);
  };
  url$$1 = url.parse(req.url);
  req.path = url$$1.pathname;
  req.search = url$$1.search;
  return next();
};

// src/middleware/live-reload.coffee
var LiveReload;
var livereload;
var serveStatic$1;

serveStatic$1 = function(req, res, next) {
  var contentType, file;
  switch (path.extname(req.url)) {
    case '.js':
      contentType = 'application/javascript';
      break;
    case '.coffee':
      contentType = 'application/coffeescript';
      break;
    case '.map':
      contentType = 'application/json';
      break;
    default:
      next();
  }
  if (/^\/src\/node_modules/.test(req.url)) {
    req.url = req.url.substring(4);
  }
  file = path.join(__dirname, '/..', req.url);
  res.writeHead(200, {
    'Content-Type': contentType
  });
  return fs.createReadStream(file).pipe(res);
};

LiveReload = (function() {
  function LiveReload(opts) {
    if (opts == null) {
      opts = {};
    }
    this.js = "<script src=\"/bebop.min.js\"></script>\n<script>\n  var bebop = new Bebop(" + (JSON.stringify(opts)) + ");\n  bebop.debug = true;\n  bebop.connect();\n</script>";
  }

  LiveReload.prototype.injectJs = function(res) {
    var appendScript, end, setHeader;
    appendScript = false;
    end = res.end;
    setHeader = res.setHeader;
    res.setHeader = (function(_this) {
      return function(name, value) {
        if (/text\/html/i.test(value)) {
          appendScript = true;
        } else if (name === 'Content-Length' && appendScript) {
          value = parseInt(value, 10) + _this.js.length;
        }
        return setHeader.call(res, name, value);
      };
    })(this);
    return res.end = (function(_this) {
      return function(chunk, encoding) {
        if (appendScript) {
          res.write(_this.js, encoding);
        }
        return end.call(res, chunk, encoding);
      };
    })(this);
  };

  LiveReload.prototype.middleware = function(req, res, next) {
    if (/^\/bebop|src\/client\/bebop/.test(req.url)) {
      return serveStatic$1(req, res, next);
    }
    this.injectJs(res);
    return next();
  };

  return LiveReload;

})();

var liveReload = livereload = function(opts) {
  var r;
  if (opts == null) {
    opts = {};
  }
  r = new LiveReload(opts);
  return function liveReload(req, res, next) { return r.middleware(req, res, next); };
};

// src/middleware/node-modules-redirect.coffee
var nodeModulesRedirect;

var nodeModulesRedirect$1 = nodeModulesRedirect = function(req, res, next) {
  var nm;
  nm = req.path.indexOf('node_modules');
  if (~nm) {
    res.writeHead(301, {
      Location: "/" + (req.path.substr(nm))
    });
    return res.end();
  } else {
    return next();
  }
};

// src/middleware/strip-html.coffee
var stripHtml;
var trailingHtmlRe;

trailingHtmlRe = /\.html$/;

var stripHtml$1 = stripHtml = function(req, res, next) {
  var loc;
  if (!trailingHtmlRe.test(req.url)) {
    return next();
  }
  loc = req.url.replace(/index.html$/, '');
  loc = loc.replace(trailingHtmlRe, '');
  return res.redirect(loc);
};

// src/middleware/strip-slash.coffee
var stripSlash;
var trailingSlashRe;

trailingSlashRe = /\.html\/$/;

var stripSlash$1 = stripSlash = function(req, res, next) {
  var loc;
  if (!trailingSlashRe.test(req.url)) {
    return next();
  }
  loc = req.url.replace(trailingSlashRe, '.html');
  return res.redirect(loc);
};

// assets/github-markdown.css
var css = "";

// src/middleware/markdown.coffee
marked.setOptions({
  renderer: new marked.Renderer(),
  breaks: false,
  gfm: true,
  pedantic: false,
  sanitize: true,
  smartLists: true,
  smartypants: false,
  tables: true
});

var markdown = function(opts) {
  var maxAge;
  if (opts == null) {
    opts = {};
  }
  maxAge = opts.maxAge || 0;
  return function(req, res, next) {
    var path$$1, pathname;
    pathname = (url__default.parse(req.url, true, true)).pathname;
    if (!/\.md$/.test(pathname)) {
      return next();
    }
    path$$1 = pathname.replace(/^\//, '');
    return fs.exists(path$$1, function(exists) {
      var now;
      if (!exists) {
        return next();
      }
      now = new Date().toUTCString();
      res.setHeader('Content-Type', 'text/html; charset=UTF-8');
      if (!res.getHeader('Cache-Control')) {
        res.setHeader('Cache-Control', 'public, max-age=' + (maxAge / 1000));
      }
      if (!res.getHeader('Date')) {
        res.setHeader('Date', now);
      }
      if (!res.getHeader('Last-Modified')) {
        res.setHeader('Last-Modified', now);
      }
      if (req.method === 'HEAD') {
        res.writeHead(200);
        return res.end();
      }
      if (req.method !== 'GET') {
        return next();
      }
      return fs.readFile(path$$1, 'utf-8', function(err, data) {
        if (err != null) {
          throw err;
        }
        res.writeHead(200);
        return res.end("<html>\n  <head>\n    <title>" + path$$1 + "</title>\n    <style>\n    " + css + "\n    </style>\n  </head>\n  <body>\n  " + (marked(data)) + "\n  </body>\n</html>");
      });
    });
  };
};

// src/middleware/index.coffee

// src/utils.coffee
var defaultExclude = /bebop.coffee$|bebop.js$/;

var requireLocal = function(modulePath) {
  var err, localPath;
  localPath = path.join(process.cwd(), '/node_modules/', modulePath);
  try {
    return require(localPath);
  } catch (error) {
    err = error;
    try {
      return require(modulePath);
    } catch (error) {
      err = error;
      log$1.error(modulePath + ' not found, try npm install -g ' + modulePath);
      return process.exit(1);
    }
  }
};

var firstAddress = function() {
  var _, addr, i, iface, len, ref;
  ref = os.networkInterfaces();
  for (_ in ref) {
    iface = ref[_];
    for (i = 0, len = iface.length; i < len; i++) {
      addr = iface[i];
      if (addr.family !== 'IPv4') {
        continue;
      }
      if (addr.internal) {
        continue;
      }
      return addr.address;
    }
  }
};

// src/server.coffee
var Server;
var cacheControl;
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
var hasProp = {}.hasOwnProperty;

cacheControl = function(res, path$$1) {
  if ((serveStatic.mime.lookup(path$$1)) === 'text/html') {
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    return res.setHeader('Pragma', 'no-cache');
  }
};

Server = (function(superClass) {
  extend(Server, superClass);

  function Server(opts) {
    var app, dir, i, len, ref, ref1, ref2, ref3, serveOpts;
    if (opts == null) {
      opts = {};
    }
    if (opts.host == null) {
      opts.host = '0.0.0.0';
    }
    if (opts.port == null) {
      opts.port = 1987;
    }
    if (opts.buildDir == null) {
      opts.buildDir = process.cwd();
    }
    if (opts.workDir == null) {
      opts.workDir = process.cwd();
    }
    if (opts.hideIcon == null) {
      opts.hideIcon = false;
    }
    app = connect();
    app.use(fakeExpress);
    app.use(stripHtml$1);
    app.use(stripSlash$1);
    if (opts.hideIcon == null) {
      app.use(favicons(__dirname + '/../assets'));
    }
    app.use(logger('dev'));
    if (opts.user && opts.pass) {
      app.use(basicAuth(opts.user, opts.pass));
    }
    app.use(liveReload());
    app.use(markdown());
    serveOpts = {
      maxAge: '1d',
      setHeaders: cacheControl,
      etag: false,
      fallthrough: true,
      dotfiles: (ref = opts.dotfiles) != null ? ref : 'deny',
      extensions: (ref1 = opts.extensions) != null ? ref1 : ['html', 'htm'],
      index: (ref2 = opts.index) != null ? ref2 : ['index.html', 'index.htm']
    };
    app.use(serveStatic(opts.buildDir, serveOpts));
    app.use(serveIndex(opts.buildDir, {
      hidden: true
    }));
    app.use('/node_modules', serveStatic(process.cwd() + '/node_modules', serveOpts));
    app.use(nodeModulesRedirect$1);
    ref3 = [opts.assetDir, opts.workDir];
    for (i = 0, len = ref3.length; i < len; i++) {
      dir = ref3[i];
      if ((dir != null) && dir !== '' && dir !== opts.buildDir) {
        app.use(serveStatic(dir, serveOpts));
      }
    }
    Server.__super__.constructor.call(this, this.app = app);
    this.opts = opts;
  }

  Server.prototype.run = function(cb) {
    var host, port, ref, workDir;
    if (cb == null) {
      cb = function() {};
    }
    ref = this.opts, workDir = ref.workDir, host = ref.host, port = ref.port;
    this.once('listening', function() {
      var dir;
      dir = path.basename(workDir);
      if (host === '0.0.0.0') {
        host = firstAddress();
        log$1.bebop("serving " + dir + " at");
        console.log("    http://" + host + ":" + port);
        return console.log("    http://localhost:" + port);
      } else {
        return log$1.bebop("serving " + dir + " at http://" + host + ":" + port);
      }
    });
    process.once('uncaughtException', (function(_this) {
      return function(err) {
        if (err.code === 'EADDRINUSE') {
          log$1.error('address in use, retrying...');
          _this.close();
          _this.opts.port++;
          return setTimeout((function() {
            return _this.run();
          }), 1000);
        } else {
          return log$1.error(err);
        }
      };
    })(this));
    return this.listen(port, host, cb);
  };

  return Server;

})(http.Server);

var Server$1 = Server;

// node_modules/es-tostring/index.mjs
var toString = function(obj) {
  return Object.prototype.toString.call(obj)
};

// node_modules/es-hasown/index.mjs
var hasOwn = function(obj, prop) {
  return {}.hasOwnProperty.call(obj, prop)
};

// node_modules/es-is/bool.js
// Generated by CoffeeScript 1.12.5
var isBool;

var isBool$1 = isBool = function(value) {
  return toString(value) === '[object Boolean]';
};

// node_modules/es-is/infinite.js
// Generated by CoffeeScript 1.12.5
var isInfinite;

var isInfinite$1 = isInfinite = function(value) {
  return value === 2e308 || value === -2e308;
};

// node_modules/es-is/number.js
// Generated by CoffeeScript 1.12.5
var isNumber;

var isNumber$1 = isNumber = function(value) {
  return toString(value) === '[object Number]';
};

// node_modules/es-is/array-like.js
// Generated by CoffeeScript 1.12.5
var isArrayLike;

var isArrayLike$1 = isArrayLike = function(value) {
  return !!value && !isBool$1(value) && hasOwn(value, 'length') && isFinite(value.length) && isNumber$1(value.length) && value.length >= 0;
};

// node_modules/es-is/array.js
// Generated by CoffeeScript 1.12.5
var isArray;

var isArray$1 = isArray = Array.isArray || function(value) {
  return toString(value) === '[object Array]';
};

// node_modules/es-is/function.js
// Generated by CoffeeScript 1.12.5
var isFunction;

var isFunction$1 = isFunction = function(value) {
  var str;
  if (typeof window !== 'undefined' && value === window.alert) {
    return true;
  }
  str = toString(value);
  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';
};

// node_modules/es-is/object.js
// Generated by CoffeeScript 1.12.5
var isObject;

var isObject$1 = isObject = function(value) {
  return toString(value) === '[object Object]';
};

// node_modules/es-is/arguments.js
// Generated by CoffeeScript 1.12.5
var isArguments;

var isArguments$1 = isArguments = function(value) {
  var isOldArguments, isStandardArguments;
  isStandardArguments = toString(value) === '[object Arguments]';
  isOldArguments = !isArray$1(value) && isArrayLike$1(value) && isObject$1(value) && isFunction$1(value.callee);
  return isStandardArguments || isOldArguments;
};

// node_modules/es-is/async-function.js
// Generated by CoffeeScript 1.12.5
var isAsyncFunction;

isAsyncFunction = function(value) {
  return toString(value) === '[object AsyncFunction]';
};

// node_modules/es-is/string.js
// Generated by CoffeeScript 1.12.5
var isString;

var isString$1 = isString = function(value) {
  return toString(value) === '[object String]';
};

// node_modules/es-is/base64.js
// Generated by CoffeeScript 1.12.5
var base64Regex;
var isBase64;

base64Regex = /^([A-Za-z0-9+\/]{4})*([A-Za-z0-9+\/]{4}|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{2}==)$/;

isBase64 = function(value) {
  return isString$1(value) && (!value.length || base64Regex.test(value));
};

// node_modules/es-is/date.js
// Generated by CoffeeScript 1.12.5
var isDate;

var isDate$1 = isDate = function(value) {
  return toString(value) === '[object Date]';
};

// node_modules/es-is/utils.js
// Generated by CoffeeScript 1.12.5
var isActualNaN = function(value) {
  return value !== value;
};

// node_modules/es-is/decimal.js
// Generated by CoffeeScript 1.12.5
var isDecimal;

isDecimal = function(value) {
  return isNumber$1(value) && !isActualNaN(value) && !isInfinite$1(value) && value % 1 !== 0;
};

// node_modules/es-is/defined.js
// Generated by CoffeeScript 1.12.5
var isDefined;

isDefined = function(value) {
  return typeof value !== 'undefined';
};

// node_modules/es-is/divisible-by.js
// Generated by CoffeeScript 1.12.5
var isDivisibleBy;

isDivisibleBy = function(value, n) {
  var isDividendInfinite, isDivisorInfinite, isNonZeroNumber;
  isDividendInfinite = isInfinite$1(value);
  isDivisorInfinite = isInfinite$1(n);
  isNonZeroNumber = isNumber$1(value) && !isActualNaN(value) && isNumber$1(n) && !isActualNaN(n) && n !== 0;
  return isDividendInfinite || isDivisorInfinite || isNonZeroNumber && value % n === 0;
};

// node_modules/es-is/element.js
// Generated by CoffeeScript 1.12.5
var isElement;

isElement = function(value) {
  return value !== void 0 && typeof HTMLElement !== 'undefined' && value instanceof HTMLElement && value.nodeType === 1;
};

// node_modules/es-is/empty-arguments.js
// Generated by CoffeeScript 1.12.5
var isEmptyArguments;

isEmptyArguments = function(value) {
  return isArguments$1(value) && value.length === 0;
};

// node_modules/es-is/empty-array.js
// Generated by CoffeeScript 1.12.5
var isEmptyArray;

isEmptyArray = function(value) {
  return isArray$1(value) && value.length === 0;
};

// node_modules/es-is/empty.js
// Generated by CoffeeScript 1.12.5
var isEmpty;

isEmpty = function(value) {
  var key, type;
  type = toString(value);
  if (type === '[object Array]' || type === '[object Arguments]' || type === '[object String]') {
    return value.length === 0;
  }
  if (type === '[object Object]') {
    for (key in value) {
      if (hasOwn(value, key)) {
        return false;
      }
    }
    return true;
  }
  return !value;
};

// node_modules/es-is/equal.js
// Generated by CoffeeScript 1.12.5
var isEqual;

isEqual = function(value, other) {
  var key, type;
  if (value === other) {
    return true;
  }
  type = toString(value);
  if (type !== toString(other)) {
    return false;
  }
  if (type === '[object Object]') {
    for (key in value) {
      if (!isEqual(value[key], other[key]) || !(key in other)) {
        return false;
      }
    }
    for (key in other) {
      if (!isEqual(value[key], other[key]) || !(key in value)) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Array]') {
    key = value.length;
    if (key !== other.length) {
      return false;
    }
    while (key--) {
      if (!isEqual(value[key], other[key])) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Function]') {
    return value.prototype === other.prototype;
  }
  if (type === '[object Date]') {
    return value.getTime() === other.getTime();
  }
  return false;
};

// node_modules/es-is/error.js
// Generated by CoffeeScript 1.12.5
var isError;

isError = function(value) {
  return toString(value) === '[object Error]';
};

// node_modules/es-is/even.js
// Generated by CoffeeScript 1.12.5
var isEven;

isEven = function(value) {
  return isInfinite$1(value) || isNumber$1(value) && value === value && value % 2 === 0;
};

// node_modules/es-is/false.js
// Generated by CoffeeScript 1.12.5
var isFalse;

isFalse = function(value) {
  return isBool$1(value) && Boolean(Number(value)) === false;
};

// node_modules/es-is/generator-function.js
// Generated by CoffeeScript 1.12.5
var isGeneratorFunction;

isGeneratorFunction = function(value) {
  return toString(value) === '[object GeneratorFunction]';
};

// node_modules/es-is/generator.js
// Generated by CoffeeScript 1.12.5
var isGenerator;

isGenerator = function(value) {
  return (isFunction$1(typeof g !== "undefined" && g !== null ? g.next : void 0)) && (isFunction$1(g["throw"]));
};

// node_modules/es-is/ge.js
// Generated by CoffeeScript 1.12.5
var isGe;

isGe = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value >= other;
};

// node_modules/es-is/gt.js
// Generated by CoffeeScript 1.12.5
var isGt;

isGt = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value > other;
};

// node_modules/es-is/hash.js
// Generated by CoffeeScript 1.12.5
var isHash;

isHash = function(value) {
  return isObject$1(value) && value.constructor === Object && !value.nodeType && !value.setInterval;
};

// node_modules/es-is/hex.js
// Generated by CoffeeScript 1.12.5
var hexRegex;
var isHex;

hexRegex = /^[A-Fa-f0-9]+$/;

isHex = function(value) {
  return isString$1(value) && (!value.length || hexRegex.test(value));
};

// node_modules/es-is/hosted.js
// Generated by CoffeeScript 1.12.5
var NON_HOST_TYPES;
var isHosted;

NON_HOST_TYPES = {
  'boolean': 1,
  number: 1,
  string: 1,
  undefined: 1
};

isHosted = function(value, host) {
  var type;
  type = typeof host[value];
  if (type === 'object') {
    return !!host[value];
  } else {
    return !NON_HOST_TYPES[type];
  }
};

// node_modules/es-is/instanceof.js
// Generated by CoffeeScript 1.12.5
var isInstanceOf;

isInstanceOf = function(value, constructor) {
  return value instanceof constructor;
};

// node_modules/es-is/integer.js
// Generated by CoffeeScript 1.12.5
var isInteger;

isInteger = function(value) {
  return isNumber$1(value) && !isActualNaN(value) && value % 1 === 0;
};

// node_modules/es-is/le.js
// Generated by CoffeeScript 1.12.5
var isLe;

isLe = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value <= other;
};

// node_modules/es-is/lt.js
// Generated by CoffeeScript 1.12.5
var isLt;

isLt = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value < other;
};

// node_modules/es-is/max.js
// Generated by CoffeeScript 1.12.5
var isMax;

isMax = function(value, others) {
  var len;
  if (isActualNaN(value)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isArrayLike$1(others)) {
    throw new TypeError('second argument must be array-like');
  }
  len = others.length;
  while (--len >= 0) {
    if (value < others[len]) {
      return false;
    }
  }
  return true;
};

// node_modules/es-is/min.js
// Generated by CoffeeScript 1.12.5
var isMin;

isMin = function(value, others) {
  var len;
  if (isActualNaN(value)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isArrayLike$1(others)) {
    throw new TypeError('second argument must be array-like');
  }
  len = others.length;
  while (--len >= 0) {
    if (value > others[len]) {
      return false;
    }
  }
  return true;
};

// node_modules/es-is/nan.js
// Generated by CoffeeScript 1.12.5
var isNaN$1;

isNaN$1 = function(value) {
  return !isNumber$1(value) || value !== value;
};

// node_modules/es-is/null.js
// Generated by CoffeeScript 1.12.5
var isNull;

isNull = function(value) {
  return value === null;
};

// node_modules/es-is/odd.js
// Generated by CoffeeScript 1.12.5
var isOdd;

isOdd = function(value) {
  return isInfinite$1(value) || isNumber$1(value) && value === value && value % 2 !== 0;
};

// node_modules/es-is/primitive.js
// Generated by CoffeeScript 1.12.5
var isPrimitive;

isPrimitive = function(value) {
  if (!value) {
    return true;
  }
  if (typeof value === 'object' || isObject$1(value) || isFunction$1(value) || isArray$1(value)) {
    return false;
  }
  return true;
};

// node_modules/es-is/promise.js
// Generated by CoffeeScript 1.12.5
var isPromise;

var isPromise$1 = isPromise = function(value) {
  return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
};

// node_modules/es-is/regexp.js
// Generated by CoffeeScript 1.12.5
var isRegExp;

isRegExp = function(value) {
  return toString(value) === '[object RegExp]';
};

// node_modules/es-is/symbol.js
// Generated by CoffeeScript 1.12.5
var isSymbol;
var symbolValueOf;

symbolValueOf = typeof Symbol === 'function' ? Symbol.prototype.valueOf : void 0;

isSymbol = function(value) {
  return typeof Symbol === 'function' && toString(value) === '[object Symbol]' && typeof symbolValueOf.call(value) === 'symbol';
};

// node_modules/es-is/true.js
// Generated by CoffeeScript 1.12.5
var isTrue;

isTrue = function(value) {
  return isBool$1(value) && Boolean(Number(value)) === true;
};

// node_modules/es-is/type.js
// Generated by CoffeeScript 1.12.5
var isType;

isType = function(value, type) {
  return typeof value === type;
};

// node_modules/es-is/undefined.js
// Generated by CoffeeScript 1.12.5
var isUndefined;

isUndefined = function(value) {
  return typeof value === 'undefined';
};

// node_modules/es-is/valid-date.js
// Generated by CoffeeScript 1.12.5
var isValidDate;

isValidDate = function(value) {
  return isDate$1(value) && !isNaN(Number(value));
};

// node_modules/es-is/within.js
// Generated by CoffeeScript 1.12.5
var isWithin;

isWithin = function(value, start, finish) {
  var isAnyInfinite;
  if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isNumber$1(value) || !isNumber$1(start) || !isNumber$1(finish)) {
    throw new TypeError('all arguments must be numbers');
  }
  isAnyInfinite = isInfinite$1(value) || isInfinite$1(start) || isInfinite$1(finish);
  return isAnyInfinite || value >= start && value <= finish;
};

// node_modules/es-is/index.mjs
// Generated by CoffeeScript 1.12.5

// src/websocket.coffee
var WebSocketServer;

WebSocketServer = (function() {
  function WebSocketServer(server, opts) {
    this.server = server;
    if (opts == null) {
      opts = {};
    }
    if (opts.path == null) {
      opts.path = '/_bebop';
    }
    if (opts.perMessageDeflate == null) {
      opts.perMessageDeflate = false;
    }
    opts.server = this.server;
    this.clients = {};
    this.id = 0;
    this.opts = opts;
    this.server.on('listening', (function(_this) {
      return function() {
        return _this.attach();
      };
    })(this));
  }

  WebSocketServer.prototype.attach = function() {
    this.wss = new ws.Server(this.opts);
    this.server.once('close', (function(_this) {
      return function() {
        return _this.close();
      };
    })(this));
    return this.wss.on('connection', (function(_this) {
      return function(ws$$1) {
        _this.id += 1;
        ws$$1.id = id;
        _this.clients[ws$$1.id] = ws$$1;
        return ws$$1.on('close', function() {
          return delete _this.clients[ws$$1.id];
        });
      };
    })(this));
  };

  WebSocketServer.prototype.close = function() {
    var id;
    for (id in this.clients) {
      this.clients[id].close();
      delete this.clients[id];
    }
    return this.wss.close();
  };

  WebSocketServer.prototype.send = function(message) {
    var err, id, results;
    results = [];
    for (id in this.clients) {
      try {
        results.push(this.clients[id].send(JSON.stringify(message)));
      } catch (error) {
        err = error;
        results.push(console.error(err.stack));
      }
    }
    return results;
  };

  WebSocketServer.prototype.modified = function(filename) {
    return this.send({
      type: 'modified',
      filename: filename
    });
  };

  return WebSocketServer;

})();

// src/compilers/sass.coffee
var findNpm;
var resolveNpm;

findNpm = function(url$$1) {
  var err;
  try {
    return path.relative(process.cwd(), require.resolve(url$$1));
  } catch (error) {
    err = error;
    return path.relative(process.cwd(), require.resolve(url$$1));
  }
};

resolveNpm = (function() {
  var cache;
  cache = {};
  return function(url$$1, file, cb) {
    var e, newPath;
    if (cache[url$$1] != null) {
      return cb({
        file: cache[url$$1]
      });
    }
    try {
      newPath = findNpm(url$$1);
      cache[url$$1] = newPath;
      return cb({
        file: newPath
      });
    } catch (error) {
      e = error;
      cache[url$$1] = url$$1;
      return cb({
        file: url$$1
      });
    }
  };
})();

var sass = function(src, dst, cb) {
  var sass;
  sass = requireLocal('node-sass');
  return sass.render({
    file: src,
    includePaths: [path.join(process.cwd(), 'node_modules')],
    outputStyle: 'nested'
  }, function(err, res) {
    if (err != null) {
      throw err;
    }
    return fs.writeFile(dst, res.css, function(err) {
      if (err != null) {
        throw err;
      }
      return cb(null, true);
    });
  });
};

// src/compilers/pug.coffee
var pug = function(src, dst, cb) {
  var html, pug;
  if (cb == null) {
    cb = function() {};
  }
  pug = requireLocal('pug');
  html = pug.renderFile(src, {
    pretty: true
  });
  return fs.writeFile(dst, html, function(err) {
    if (err != null) {
      throw err;
    }
    return cb(null, true);
  });
};

// src/compilers/index.coffee
var compilers;

var compilers$1 = compilers = {
  mappings: {
    coffee: 'js',
    hbs: 'html',
    jade: 'html',
    pug: 'html',
    sass: 'css',
    scss: 'css',
    styl: 'css'
  },
  compile: function(filename, opts, cb) {
    var c, cmd, cmds, compiler, dst, ext, ref, src;
    if (opts == null) {
      opts = {};
    }
    if (cb == null) {
      cb = function() {};
    }
    if (typeof opts === 'function') {
      ref = [{}, opts], opts = ref[0], cb = ref[1];
    }
    ext = (path.extname(filename)).substr(1);
    if ((compiler = this[ext]) == null) {
      return cb(null, false);
    }
    src = filename;
    dst = filename.replace(new RegExp(ext + '$'), this.mappings[ext]);
    if (opts.buildDir != null) {
      dst = dst.replace(opts.assetDir, opts.buildDir);
    }
    if (compiler.length === 3) {
      return compiler(src, dst, cb);
    }
    cmd = compiler(src, dst);
    if (isFunction$1(cmd)) {
      return cmd(cb);
    }
    if (isPromise$1(cmd)) {
      return cmd;
    }
    if (!isString$1(cmd)) {
      return cb(null, cmd != null ? cmd : false);
    }
    cmds = (function() {
      var i, len, ref1, results;
      ref1 = cmd.split(';');
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        c = ref1[i];
        if ((c != null) && c.trim() !== '') {
          results.push(c.trim());
        }
      }
      return results;
    })();
    return exec.quiet(cmds, function(err, stdout, stderr) {
      if (err != null) {
        return cb(err);
      }
      if ((stderr != null) && stderr.trim() !== '') {
        return cb(new Error(stderr));
      }
      return cb(null, true);
    });
  },
  coffee: function(src, dst) {
    dst = path.dirname(dst);
    return "coffee -bmc -o " + dst + " " + src;
  },
  hbs: function(src, dst) {
    var handlebars, template;
    handlebars = requireLocal('handlebars');
    template = handlebars.compile(fs.readFileSync(src, 'utf8'));
    return fs.writeFileSync(dst, template({}), 'utf8');
  },
  jade: function(src, dst) {
    dst = path.dirname(dst);
    return "jade --pretty " + src + " --out " + dst;
  },
  pug: pug,
  styl: function(src, dst) {
    dst = path.dirname(dst);
    return "stylus " + src + " -o " + dst;
  },
  sass: sass,
  scss: sass
};

// package.json


var version = "1.12.4";

// src/cli.coffee
var args;
var bits;
var compile;
var compiler;
var conf;
var confs;
var credentials;
var cwd;
var err;
var error$1;
var ext;
var i;
var j;
var len;
var len1;
var mod;
var opt;
var opts;
var p;
var ref;
var ref1;
var ref2;
var ref3;
var relativeName;
var requireConfig;
var server;
var usage;
var version_;
var vigilOpts;
var websocket;

error$1 = function(message) {
  log$1.error(message);
  return process.exit(1);
};

version_ = function() {
  console.log(version);
  return process.exit(0);
};

usage = function() {
  console.log("bebop <command> [options] [file]\n\nCommands:\n  compile|c  Compile files and exit\n  help       Display this message\n  version    Display version\n\nOptions:\n  --auto                      Automatically compile even without a local config file\n  --compilers <ext:compiler>  Specify compiler to use for a given extension\n  --config <file>             Specify bebop.coffee to use\n  --exclude, -x <file>        Exclude files from watching, compiling\n  --force-reload              Force reload when file is compiled\n  --host, -h <hostname>       Hostname to bind to\n  --include, -i <file>        Include files for watching, compiling\n  --no-server                 Do not run static file server\n  --no-watch                  Do not watch files for changes\n  --open, -o                  Open browser automatically\n  --port, -p <port>           Port to listen on\n  --secure, -s <user:pass>    Require authentication\n  --asset-dir <path>          Directory used as root for compiling, watching\n  --build-dir <path>          Directory used as root for static file server\n  --work-dir  <path>          Directory used as root for process\n  --index <file>              Index file to attempt to serve when directory requested\n  --hide-icon                 Hide Bebop's favicon");
  return process.exit(0);
};

try {
  require('coffee-script/register');
} catch (error1) {
  err = error1;
}

cwd = process.cwd();

confs = [process.env.HOME + '/.bebop', cwd + '/.bebop', cwd + '/bebop'];

opts = {
  compile: false,
  compileOnly: false,
  compilers: {},
  defaultExclude: true,
  exclude: [],
  fallback: null,
  forceReload: false,
  host: '0.0.0.0',
  include: [],
  index: ['index.html', 'index.htm'],
  initialPath: '',
  port: 1987,
  runServer: true,
  watch: true,
  assetDir: cwd,
  buildDir: cwd,
  workDir: cwd,
  hideIcon: false
};

requireConfig = function(path$$1) {
  var conf, k, ref, v;
  try {
    conf = require.resolve(path$$1);
  } catch (error1) {
    err = error1;
    return;
  }
  if (fs.existsSync(conf)) {
    ref = require(conf);
    for (k in ref) {
      v = ref[k];
      opts[k] = v;
    }
    return opts.compile = true;
  }
};

for (i = 0, len = confs.length; i < len; i++) {
  conf = confs[i];
  requireConfig(conf);
}

args = process.argv.slice(2);

while (opt = args.shift()) {
  switch (opt) {
    case 'compile':
    case 'c':
    case '--compile':
    case '-c':
      opts.compile = true;
      opts.compileOnly = true;
      opts.runServer = false;
      opts.watch = false;
      break;
    case 'help':
    case '--help':
      usage();
      break;
    case 'version':
    case '--version':
    case '-v':
      version_();
      break;
    case '--config':
      requireConfig(args.shift());
      break;
    case '--open':
    case '-o':
      opts.open = true;
      break;
    case '--no-server':
      opts.runServer = false;
      break;
    case '--no-watch':
      opts.watch = false;
      break;
    case '--auto':
      opts.compile = true;
      break;
    case '--include':
    case '-i':
      opts.include.push(args.shift());
      break;
    case '--exclude':
    case '-x':
      opts.exclude.push(args.shift());
      break;
    case '--no-default-exclude':
      opts.defaultExclude = false;
      break;
    case '--force-reload':
      opts.forceReload = true;
      break;
    case '--fallback':
      opts.fallback = args.shift();
      break;
    case '--host':
    case '-h':
      opts.host = args.shift();
      break;
    case '--port':
    case '-p':
      p = args.shift();
      if (!p) {
        error$1('missing port');
      }
      opts.port = parseInt(p, 10);
      break;
    case '--secure':
    case '-s':
      credentials = args.shift();
      if (credentials) {
        ref = credentials.split(':'), opts.user = ref[0], opts.pass = ref[1];
      } else {
        opts.user = 'bebop';
        opts.pass = 'beepboop';
      }
      break;
    case '--asset-dir':
      opts.assetDir = args.shift();
      break;
    case '--build-dir':
      opts.buildDir = args.shift();
      break;
    case '--work-dir':
      opts.workDir = args.shift();
      break;
    case '--compilers':
    case '-c':
      ref1 = args.shift().split(',');
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        compiler = ref1[j];
        ref2 = compiler.split(':'), ext = ref2[0], mod = ref2[1];
        opts.compilers[ext] = mod;
      }
      break;
    case '--hide-icon':
      opts.hideIcon = true;
      break;
    default:
      if (opt.charAt(0) === '-') {
        error$1("Unrecognized option: '" + opt + "'");
      } else {
        opts.initialPath = opt;
      }
  }
}

if (opts.defaultExclude) {
  opts.exclude = [vigil.utils.excludeRe, defaultExclude].concat(opts.exclude);
}

vigilOpts = {
  exclude: opts.exclude,
  include: opts.include,
  patch: false
};

ref3 = opts.compilers;
for (ext in ref3) {
  compiler = ref3[ext];
  if (typeof compiler === 'string') {
    try {
      bits = compiler.split('.');
      compiler = require(bits.shift());
      while (bits.length) {
        compiler = compiler[bits.shift()];
      }
      compilers$1[ext] = compiler;
    } catch (error1) {
      err = error1;
      console.log(err);
    }
  } else {
    compilers$1[ext] = compiler;
  }
}

relativeName = function(filename) {
  return filename.replace(opts.workDir + '/', '');
};

compile = function(filename, cb) {
  if (cb == null) {
    cb = function() {};
  }
  return compilers$1.compile(filename, opts, function(err, compiled) {
    filename = relativeName(filename);
    if (err != null) {
      log$1.error("failed to compile " + filename, err);
      return;
    }
    if (compiled) {
      log$1.compiled(filename);
    }
    return cb(null, compiled);
  });
};

if (opts.compile) {
  vigil.walk(opts.workDir, vigilOpts, function(filename) {
    return compile(filename);
  });
}

if (opts.runServer) {
  server = new Server$1(opts);
  websocket = {
    modified: function() {}
  };
} else {
  server = {
    run: function() {}
  };
  websocket = {
    modified: function() {}
  };
}

if (opts.watch) {
  vigil.watch(opts.assetDir, vigilOpts, function(filename) {
    if (!opts.compile) {
      log$1.modified(filename);
      return websocket.modified(filename);
    }
    return compile(filename, function(err, compiled) {
      if (!compiled) {
        log$1.modified(filename);
        return websocket.modified(filename);
      } else {
        if (opts.forceReload) {
          return websocket.modified(filename);
        }
      }
    });
  });
  if (opts.buildDir !== opts.assetDir) {
    vigil.watch(opts.buildDir, vigilOpts, function(filename) {
      log$1.modified(filename);
      return websocket.modified(filename);
    });
  }
}

server.run(function() {
  if (opts.open || opts.initialPath !== '') {
    switch (os.platform()) {
      case 'darwin':
        return exec("open http://" + opts.host + ":" + opts.port + "/" + opts.initialPath);
      case 'linux':
        return exec("xdg-open http://" + opts.host + ":" + opts.port + "/" + opts.initialPath);
    }
  }
});
//# sourceMappingURL=bebop.map
