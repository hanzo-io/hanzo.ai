'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var builtins = _interopDefault(require('builtin-modules'));
var browserResolve = _interopDefault(require('browser-resolve'));
var nodeResolve = _interopDefault(require('resolve'));
var chalk = _interopDefault(require('chalk'));

// src/index.coffee
var COMMONJS_BROWSER_EMPTY;
var ES6_BROWSER_EMPTY;
var nodeResolveMagic;

COMMONJS_BROWSER_EMPTY = nodeResolve.sync('browser-resolve/empty.js', __dirname);

ES6_BROWSER_EMPTY = path.resolve(__dirname, '../src/empty.js');

nodeResolveMagic = function(opts) {
  var basedir, browser, extensions, external, packageFilter, paths, preferBuiltins, ref, ref1, ref2, ref3, ref4, ref5, ref6, resolveId, skip;
  if (opts == null) {
    opts = {};
  }
  basedir = (ref = opts.basedir) != null ? ref : null;
  browser = (ref1 = opts.browser) != null ? ref1 : false;
  extensions = (ref2 = opts.extensions) != null ? ref2 : ['.js', '.coffee', '.json'];
  external = (ref3 = opts.external) != null ? ref3 : true;
  paths = (ref4 = opts.paths) != null ? ref4 : [];
  preferBuiltins = (ref5 = opts.preferBuiltins) != null ? ref5 : true;
  skip = (ref6 = opts.skip) != null ? ref6 : [];
  if (basedir != null) {
    paths.push(basedir);
  }
  if (Array.isArray(opts.external)) {
    external = false;
    skip = skip.concat(opts.external);
  }
  skip = new Set(skip);
  resolveId = browser ? browserResolve : nodeResolve;
  packageFilter = function(pkg) {
    var k;
    if (pkg.module) {
      pkg.main = pkg.module;
    } else if (pkg['jsnext:main']) {
      pkg.main = pkg['jsnext:main'];
    }
    if (!pkg.main) {
      pkg.main = './index.js';
    }
    if (external === true && (pkg.module != null)) {
      for (k in pkg.dependencies) {
        if (skip.has(k)) {
          continue;
        }
        skip.add(k);
        console.log((" - " + k) + chalk.black(" detected as external to " + pkg.name));
      }
      for (k in pkg.peerDependencies) {
        if (skip.has(k)) {
          continue;
        }
        skip.add(k);
        console.log((" - " + k) + chalk.black(" detected as external to " + pkg.name));
      }
    }
    return pkg;
  };
  return {
    name: 'node-resolve-magic',
    resolveId: function(importee, importer) {
      var id, parts;
      if (/\0/.test(importee)) {
        return null;
      }
      if (!importer) {
        return null;
      }
      parts = importee.split(/[\/\\]/);
      id = parts.shift();
      if (id[0] === '@' && parts.length) {
        id += "/" + (parts.shift());
      } else if (id[0] === '.') {
        id = path.resolve(importer, '..', importee);
      }
      if (skip.has(id)) {
        return;
      }
      return new Promise(function(resolve, reject) {
        var resolveOpts;
        resolveOpts = {
          basedir: importee[0] === '.' ? path.dirname(importer) : basedir,
          paths: paths,
          extensions: extensions,
          packageFilter: packageFilter
        };
        return resolveId(importee, resolveOpts, function(err, resolved) {
          if (err != null) {
            return reject(new Error("Could not resolve '" + importee + "' from " + (path.normalize(importer))));
          }
          if (resolved === COMMONJS_BROWSER_EMPTY) {
            return resolve(ES6_BROWSER_EMPTY);
          }
          if (~builtins.indexOf(resolved)) {
            return resolve(null);
          }
          if (preferBuiltins && ~builtins.indexOf(importee)) {
            if (!opts.quiet) {
              console.log((" - " + importee) + chalk.black(" built-in preferred over local alternative"));
              skip.add(importee);
            }
            return resolve(null);
          }
          return fs.exists(resolved, function(exists) {
            if (!exists) {
              if (!opts.quiet) {
                console.log("resolved " + importee + " to " + resolved + ", which does not exist");
              }
              return resolve(null);
            }
            return fs.realpath(resolved, function(err, resolved) {
              if (err != null) {
                return reject(err);
              }
              return resolve(resolved);
            });
          });
        });
      });
    }
  };
};

nodeResolveMagic.browser = browserResolve;

nodeResolveMagic.node = nodeResolve;

var nodeResolveMagic$1 = nodeResolveMagic;

module.exports = nodeResolveMagic$1;
//# sourceMappingURL=rollup-plugin-node-resolve-magic.js.map
