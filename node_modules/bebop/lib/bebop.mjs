import vigil from 'vigil';
import exec from 'executive';
import fs from 'fs';
import path from 'path';
import colors from 'colors/safe';
import os from 'os';
import ws from 'ws';
import url, { parse } from 'url';
import connect$1 from 'connect';
import marked from 'marked';
import basicAuth from 'basic-auth-connect';
import favicons from 'connect-favicons';
import http from 'http';
import logger from 'morgan';
import serveIndex from 'serve-index';
import serveStatic from 'serve-static';

// node_modules/es-tostring/index.mjs
var toString = function(obj) {
  return Object.prototype.toString.call(obj)
};

// node_modules/es-hasown/index.mjs
var hasOwn = function(obj, prop) {
  return {}.hasOwnProperty.call(obj, prop)
};

// node_modules/es-is/bool.js
// Generated by CoffeeScript 1.12.5
var isBool;

var isBool$1 = isBool = function(value) {
  return toString(value) === '[object Boolean]';
};

// node_modules/es-is/infinite.js
// Generated by CoffeeScript 1.12.5
var isInfinite;

var isInfinite$1 = isInfinite = function(value) {
  return value === 2e308 || value === -2e308;
};

// node_modules/es-is/number.js
// Generated by CoffeeScript 1.12.5
var isNumber;

var isNumber$1 = isNumber = function(value) {
  return toString(value) === '[object Number]';
};

// node_modules/es-is/array-like.js
// Generated by CoffeeScript 1.12.5
var isArrayLike;

var isArrayLike$1 = isArrayLike = function(value) {
  return !!value && !isBool$1(value) && hasOwn(value, 'length') && isFinite(value.length) && isNumber$1(value.length) && value.length >= 0;
};

// node_modules/es-is/array.js
// Generated by CoffeeScript 1.12.5
var isArray;

var isArray$1 = isArray = Array.isArray || function(value) {
  return toString(value) === '[object Array]';
};

// node_modules/es-is/function.js
// Generated by CoffeeScript 1.12.5
var isFunction;

var isFunction$1 = isFunction = function(value) {
  var str;
  if (typeof window !== 'undefined' && value === window.alert) {
    return true;
  }
  str = toString(value);
  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';
};

// node_modules/es-is/object.js
// Generated by CoffeeScript 1.12.5
var isObject;

var isObject$1 = isObject = function(value) {
  return toString(value) === '[object Object]';
};

// node_modules/es-is/arguments.js
// Generated by CoffeeScript 1.12.5
var isArguments;

var isArguments$1 = isArguments = function(value) {
  var isOldArguments, isStandardArguments;
  isStandardArguments = toString(value) === '[object Arguments]';
  isOldArguments = !isArray$1(value) && isArrayLike$1(value) && isObject$1(value) && isFunction$1(value.callee);
  return isStandardArguments || isOldArguments;
};

// node_modules/es-is/async-function.js
// Generated by CoffeeScript 1.12.5
var isAsyncFunction;

isAsyncFunction = function(value) {
  return toString(value) === '[object AsyncFunction]';
};

// node_modules/es-is/string.js
// Generated by CoffeeScript 1.12.5
var isString;

var isString$1 = isString = function(value) {
  return toString(value) === '[object String]';
};

// node_modules/es-is/base64.js
// Generated by CoffeeScript 1.12.5
var base64Regex;
var isBase64;

base64Regex = /^([A-Za-z0-9+\/]{4})*([A-Za-z0-9+\/]{4}|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{2}==)$/;

isBase64 = function(value) {
  return isString$1(value) && (!value.length || base64Regex.test(value));
};

// node_modules/es-is/date.js
// Generated by CoffeeScript 1.12.5
var isDate;

var isDate$1 = isDate = function(value) {
  return toString(value) === '[object Date]';
};

// node_modules/es-is/utils.js
// Generated by CoffeeScript 1.12.5
var isActualNaN = function(value) {
  return value !== value;
};

// node_modules/es-is/decimal.js
// Generated by CoffeeScript 1.12.5
var isDecimal;

isDecimal = function(value) {
  return isNumber$1(value) && !isActualNaN(value) && !isInfinite$1(value) && value % 1 !== 0;
};

// node_modules/es-is/defined.js
// Generated by CoffeeScript 1.12.5
var isDefined;

isDefined = function(value) {
  return typeof value !== 'undefined';
};

// node_modules/es-is/divisible-by.js
// Generated by CoffeeScript 1.12.5
var isDivisibleBy;

isDivisibleBy = function(value, n) {
  var isDividendInfinite, isDivisorInfinite, isNonZeroNumber;
  isDividendInfinite = isInfinite$1(value);
  isDivisorInfinite = isInfinite$1(n);
  isNonZeroNumber = isNumber$1(value) && !isActualNaN(value) && isNumber$1(n) && !isActualNaN(n) && n !== 0;
  return isDividendInfinite || isDivisorInfinite || isNonZeroNumber && value % n === 0;
};

// node_modules/es-is/element.js
// Generated by CoffeeScript 1.12.5
var isElement;

isElement = function(value) {
  return value !== void 0 && typeof HTMLElement !== 'undefined' && value instanceof HTMLElement && value.nodeType === 1;
};

// node_modules/es-is/empty-arguments.js
// Generated by CoffeeScript 1.12.5
var isEmptyArguments;

isEmptyArguments = function(value) {
  return isArguments$1(value) && value.length === 0;
};

// node_modules/es-is/empty-array.js
// Generated by CoffeeScript 1.12.5
var isEmptyArray;

isEmptyArray = function(value) {
  return isArray$1(value) && value.length === 0;
};

// node_modules/es-is/empty.js
// Generated by CoffeeScript 1.12.5
var isEmpty;

isEmpty = function(value) {
  var key, type;
  type = toString(value);
  if (type === '[object Array]' || type === '[object Arguments]' || type === '[object String]') {
    return value.length === 0;
  }
  if (type === '[object Object]') {
    for (key in value) {
      if (hasOwn(value, key)) {
        return false;
      }
    }
    return true;
  }
  return !value;
};

// node_modules/es-is/equal.js
// Generated by CoffeeScript 1.12.5
var isEqual;

isEqual = function(value, other) {
  var key, type;
  if (value === other) {
    return true;
  }
  type = toString(value);
  if (type !== toString(other)) {
    return false;
  }
  if (type === '[object Object]') {
    for (key in value) {
      if (!isEqual(value[key], other[key]) || !(key in other)) {
        return false;
      }
    }
    for (key in other) {
      if (!isEqual(value[key], other[key]) || !(key in value)) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Array]') {
    key = value.length;
    if (key !== other.length) {
      return false;
    }
    while (key--) {
      if (!isEqual(value[key], other[key])) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Function]') {
    return value.prototype === other.prototype;
  }
  if (type === '[object Date]') {
    return value.getTime() === other.getTime();
  }
  return false;
};

// node_modules/es-is/error.js
// Generated by CoffeeScript 1.12.5
var isError;

isError = function(value) {
  return toString(value) === '[object Error]';
};

// node_modules/es-is/even.js
// Generated by CoffeeScript 1.12.5
var isEven;

isEven = function(value) {
  return isInfinite$1(value) || isNumber$1(value) && value === value && value % 2 === 0;
};

// node_modules/es-is/false.js
// Generated by CoffeeScript 1.12.5
var isFalse;

isFalse = function(value) {
  return isBool$1(value) && Boolean(Number(value)) === false;
};

// node_modules/es-is/generator-function.js
// Generated by CoffeeScript 1.12.5
var isGeneratorFunction;

isGeneratorFunction = function(value) {
  return toString(value) === '[object GeneratorFunction]';
};

// node_modules/es-is/generator.js
// Generated by CoffeeScript 1.12.5
var isGenerator;

isGenerator = function(value) {
  return (isFunction$1(typeof g !== "undefined" && g !== null ? g.next : void 0)) && (isFunction$1(g["throw"]));
};

// node_modules/es-is/ge.js
// Generated by CoffeeScript 1.12.5
var isGe;

isGe = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value >= other;
};

// node_modules/es-is/gt.js
// Generated by CoffeeScript 1.12.5
var isGt;

isGt = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value > other;
};

// node_modules/es-is/hash.js
// Generated by CoffeeScript 1.12.5
var isHash;

isHash = function(value) {
  return isObject$1(value) && value.constructor === Object && !value.nodeType && !value.setInterval;
};

// node_modules/es-is/hex.js
// Generated by CoffeeScript 1.12.5
var hexRegex;
var isHex;

hexRegex = /^[A-Fa-f0-9]+$/;

isHex = function(value) {
  return isString$1(value) && (!value.length || hexRegex.test(value));
};

// node_modules/es-is/hosted.js
// Generated by CoffeeScript 1.12.5
var NON_HOST_TYPES;
var isHosted;

NON_HOST_TYPES = {
  'boolean': 1,
  number: 1,
  string: 1,
  undefined: 1
};

isHosted = function(value, host) {
  var type;
  type = typeof host[value];
  if (type === 'object') {
    return !!host[value];
  } else {
    return !NON_HOST_TYPES[type];
  }
};

// node_modules/es-is/instanceof.js
// Generated by CoffeeScript 1.12.5
var isInstanceOf;

isInstanceOf = function(value, constructor) {
  return value instanceof constructor;
};

// node_modules/es-is/integer.js
// Generated by CoffeeScript 1.12.5
var isInteger;

isInteger = function(value) {
  return isNumber$1(value) && !isActualNaN(value) && value % 1 === 0;
};

// node_modules/es-is/le.js
// Generated by CoffeeScript 1.12.5
var isLe;

isLe = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value <= other;
};

// node_modules/es-is/lt.js
// Generated by CoffeeScript 1.12.5
var isLt;

isLt = function(value, other) {
  if (isActualNaN(value) || isActualNaN(other)) {
    throw new TypeError('NaN is not a valid value');
  }
  return !isInfinite$1(value) && !isInfinite$1(other) && value < other;
};

// node_modules/es-is/max.js
// Generated by CoffeeScript 1.12.5
var isMax;

isMax = function(value, others) {
  var len;
  if (isActualNaN(value)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isArrayLike$1(others)) {
    throw new TypeError('second argument must be array-like');
  }
  len = others.length;
  while (--len >= 0) {
    if (value < others[len]) {
      return false;
    }
  }
  return true;
};

// node_modules/es-is/min.js
// Generated by CoffeeScript 1.12.5
var isMin;

isMin = function(value, others) {
  var len;
  if (isActualNaN(value)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isArrayLike$1(others)) {
    throw new TypeError('second argument must be array-like');
  }
  len = others.length;
  while (--len >= 0) {
    if (value > others[len]) {
      return false;
    }
  }
  return true;
};

// node_modules/es-is/nan.js
// Generated by CoffeeScript 1.12.5
var isNaN$1;

isNaN$1 = function(value) {
  return !isNumber$1(value) || value !== value;
};

// node_modules/es-is/null.js
// Generated by CoffeeScript 1.12.5
var isNull;

isNull = function(value) {
  return value === null;
};

// node_modules/es-is/odd.js
// Generated by CoffeeScript 1.12.5
var isOdd;

isOdd = function(value) {
  return isInfinite$1(value) || isNumber$1(value) && value === value && value % 2 !== 0;
};

// node_modules/es-is/primitive.js
// Generated by CoffeeScript 1.12.5
var isPrimitive;

isPrimitive = function(value) {
  if (!value) {
    return true;
  }
  if (typeof value === 'object' || isObject$1(value) || isFunction$1(value) || isArray$1(value)) {
    return false;
  }
  return true;
};

// node_modules/es-is/promise.js
// Generated by CoffeeScript 1.12.5
var isPromise;

var isPromise$1 = isPromise = function(value) {
  return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
};

// node_modules/es-is/regexp.js
// Generated by CoffeeScript 1.12.5
var isRegExp;

isRegExp = function(value) {
  return toString(value) === '[object RegExp]';
};

// node_modules/es-is/symbol.js
// Generated by CoffeeScript 1.12.5
var isSymbol;
var symbolValueOf;

symbolValueOf = typeof Symbol === 'function' ? Symbol.prototype.valueOf : void 0;

isSymbol = function(value) {
  return typeof Symbol === 'function' && toString(value) === '[object Symbol]' && typeof symbolValueOf.call(value) === 'symbol';
};

// node_modules/es-is/true.js
// Generated by CoffeeScript 1.12.5
var isTrue;

isTrue = function(value) {
  return isBool$1(value) && Boolean(Number(value)) === true;
};

// node_modules/es-is/type.js
// Generated by CoffeeScript 1.12.5
var isType;

isType = function(value, type) {
  return typeof value === type;
};

// node_modules/es-is/undefined.js
// Generated by CoffeeScript 1.12.5
var isUndefined;

isUndefined = function(value) {
  return typeof value === 'undefined';
};

// node_modules/es-is/valid-date.js
// Generated by CoffeeScript 1.12.5
var isValidDate;

isValidDate = function(value) {
  return isDate$1(value) && !isNaN(Number(value));
};

// node_modules/es-is/within.js
// Generated by CoffeeScript 1.12.5
var isWithin;

isWithin = function(value, start, finish) {
  var isAnyInfinite;
  if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {
    throw new TypeError('NaN is not a valid value');
  } else if (!isNumber$1(value) || !isNumber$1(start) || !isNumber$1(finish)) {
    throw new TypeError('all arguments must be numbers');
  }
  isAnyInfinite = isInfinite$1(value) || isInfinite$1(start) || isInfinite$1(finish);
  return isAnyInfinite || value >= start && value <= finish;
};

// node_modules/es-is/index.mjs
// Generated by CoffeeScript 1.12.5

// src/log.coffee
var _;
var fn;
var log;
var method;
var prettyError;
var prettyJSON;
var theme;

theme = {
  debug: 'blue',
  info: 'white',
  warn: 'yellow',
  error: 'red',
  bebop: 'black',
  modified: 'cyan',
  compiled: 'blue'
};

colors.setTheme(theme);

prettyJSON = function(obj) {
  return JSON.stringify(obj, null, 2);
};

prettyError = function(err) {
  var msg, std;
  std = [];
  if (err.stdout != null) {
    std.push(err.stdout);
  }
  if (err.stderr != null) {
    std.push(err.stderr);
  }
  if (std.length > 0) {
    return std.join('\n');
  } else {
    msg = err.stack;
    return msg = msg.replace(/^Error: /, '');
  }
};

log = function() {
  if (root.console == null) {
    return console.log.apply(console, arguments);
  }
};

fn = function(method) {
  var prefix;
  prefix = colors[method](method + ' ');
  return log[method] = function(msg, extra) {
    var err;
    err = null;
    switch (typeof msg) {
      case 'string':
        msg = msg;
        break;
      case 'object':
        if (msg instanceof Error) {
          msg = prettyError(msg);
        } else {
          msg = '\n' + prettyJSON(msg);
        }
    }
    if (extra instanceof Error) {
      extra = prettyError(extra);
    } else {
      extra = prettyJSON(extra);
    }
    if (extra != null) {
      msg = msg + '\n' + extra;
    }
    msg = prefix + msg;
    if (err != null) {
      return console.error(msg);
    } else {
      return console.log(msg);
    }
  };
};
for (method in theme) {
  _ = theme[method];
  fn(method);
}

var log$1 = log;

// src/utils.coffee


var requireLocal = function(modulePath) {
  var err, localPath;
  localPath = path.join(process.cwd(), '/node_modules/', modulePath);
  try {
    return require(localPath);
  } catch (error) {
    err = error;
    try {
      return require(modulePath);
    } catch (error) {
      err = error;
      log$1.error(modulePath + ' not found, try npm install -g ' + modulePath);
      return process.exit(1);
    }
  }
};

var firstAddress = function() {
  var _, addr, i, iface, len, ref;
  ref = os.networkInterfaces();
  for (_ in ref) {
    iface = ref[_];
    for (i = 0, len = iface.length; i < len; i++) {
      addr = iface[i];
      if (addr.family !== 'IPv4') {
        continue;
      }
      if (addr.internal) {
        continue;
      }
      return addr.address;
    }
  }
};

// src/compilers/sass.coffee
var findNpm;
var resolveNpm;

findNpm = function(url$$1) {
  var err;
  try {
    return path.relative(process.cwd(), require.resolve(url$$1));
  } catch (error) {
    err = error;
    return path.relative(process.cwd(), require.resolve(url$$1));
  }
};

resolveNpm = (function() {
  var cache;
  cache = {};
  return function(url$$1, file, cb) {
    var e, newPath;
    if (cache[url$$1] != null) {
      return cb({
        file: cache[url$$1]
      });
    }
    try {
      newPath = findNpm(url$$1);
      cache[url$$1] = newPath;
      return cb({
        file: newPath
      });
    } catch (error) {
      e = error;
      cache[url$$1] = url$$1;
      return cb({
        file: url$$1
      });
    }
  };
})();

var sass = function(src, dst, cb) {
  var sass;
  sass = requireLocal('node-sass');
  return sass.render({
    file: src,
    includePaths: [path.join(process.cwd(), 'node_modules')],
    outputStyle: 'nested'
  }, function(err, res) {
    if (err != null) {
      throw err;
    }
    return fs.writeFile(dst, res.css, function(err) {
      if (err != null) {
        throw err;
      }
      return cb(null, true);
    });
  });
};

// src/compilers/pug.coffee
var pug = function(src, dst, cb) {
  var html, pug;
  if (cb == null) {
    cb = function() {};
  }
  pug = requireLocal('pug');
  html = pug.renderFile(src, {
    pretty: true
  });
  return fs.writeFile(dst, html, function(err) {
    if (err != null) {
      throw err;
    }
    return cb(null, true);
  });
};

// src/compilers/index.coffee
var compilers;

var index$1 = compilers = {
  mappings: {
    coffee: 'js',
    hbs: 'html',
    jade: 'html',
    pug: 'html',
    sass: 'css',
    scss: 'css',
    styl: 'css'
  },
  compile: function(filename, opts, cb) {
    var c, cmd, cmds, compiler, dst, ext, ref, src;
    if (opts == null) {
      opts = {};
    }
    if (cb == null) {
      cb = function() {};
    }
    if (typeof opts === 'function') {
      ref = [{}, opts], opts = ref[0], cb = ref[1];
    }
    ext = (path.extname(filename)).substr(1);
    if ((compiler = this[ext]) == null) {
      return cb(null, false);
    }
    src = filename;
    dst = filename.replace(new RegExp(ext + '$'), this.mappings[ext]);
    if (opts.buildDir != null) {
      dst = dst.replace(opts.assetDir, opts.buildDir);
    }
    if (compiler.length === 3) {
      return compiler(src, dst, cb);
    }
    cmd = compiler(src, dst);
    if (isFunction$1(cmd)) {
      return cmd(cb);
    }
    if (isPromise$1(cmd)) {
      return cmd;
    }
    if (!isString$1(cmd)) {
      return cb(null, cmd != null ? cmd : false);
    }
    cmds = (function() {
      var i, len, ref1, results;
      ref1 = cmd.split(';');
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        c = ref1[i];
        if ((c != null) && c.trim() !== '') {
          results.push(c.trim());
        }
      }
      return results;
    })();
    return exec.quiet(cmds, function(err, stdout, stderr) {
      if (err != null) {
        return cb(err);
      }
      if ((stderr != null) && stderr.trim() !== '') {
        return cb(new Error(stderr));
      }
      return cb(null, true);
    });
  },
  coffee: function(src, dst) {
    dst = path.dirname(dst);
    return "coffee -bmc -o " + dst + " " + src;
  },
  hbs: function(src, dst) {
    var handlebars, template;
    handlebars = requireLocal('handlebars');
    template = handlebars.compile(fs.readFileSync(src, 'utf8'));
    return fs.writeFileSync(dst, template({}), 'utf8');
  },
  jade: function(src, dst) {
    dst = path.dirname(dst);
    return "jade --pretty " + src + " --out " + dst;
  },
  pug: pug,
  styl: function(src, dst) {
    dst = path.dirname(dst);
    return "stylus " + src + " -o " + dst;
  },
  sass: sass,
  scss: sass
};

// src/inject.coffee
var injectConnectApp = function(app) {
  app.stack.splice(2, 0, {
    route: '',
    handle: _middleware
  });
  return app;
};

var injectHttpServer = function(server) {
  var app;
  app = server.listeners('request')[0];
  if (typeof app === 'function') {
    server.removeListener('request', app);
  }
  server.on('request', function(req, res) {
    return _middleware(req, res, function() {
      return app(req, res);
    });
  });
  return server;
};

var inject = function(app) {
  if (connect().toString() === app.toString()) {
    return injectConnectApp(app);
  } else {
    return injectHttpServer(app);
  }
};

// src/websocket.coffee
var WebSocketServer;

WebSocketServer = (function() {
  function WebSocketServer(server, opts) {
    this.server = server;
    if (opts == null) {
      opts = {};
    }
    if (opts.path == null) {
      opts.path = '/_bebop';
    }
    if (opts.perMessageDeflate == null) {
      opts.perMessageDeflate = false;
    }
    opts.server = this.server;
    this.clients = {};
    this.id = 0;
    this.opts = opts;
    this.server.on('listening', (function(_this) {
      return function() {
        return _this.attach();
      };
    })(this));
  }

  WebSocketServer.prototype.attach = function() {
    this.wss = new ws.Server(this.opts);
    this.server.once('close', (function(_this) {
      return function() {
        return _this.close();
      };
    })(this));
    return this.wss.on('connection', (function(_this) {
      return function(ws$$1) {
        _this.id += 1;
        ws$$1.id = id;
        _this.clients[ws$$1.id] = ws$$1;
        return ws$$1.on('close', function() {
          return delete _this.clients[ws$$1.id];
        });
      };
    })(this));
  };

  WebSocketServer.prototype.close = function() {
    var id;
    for (id in this.clients) {
      this.clients[id].close();
      delete this.clients[id];
    }
    return this.wss.close();
  };

  WebSocketServer.prototype.send = function(message) {
    var err, id, results;
    results = [];
    for (id in this.clients) {
      try {
        results.push(this.clients[id].send(JSON.stringify(message)));
      } catch (error) {
        err = error;
        results.push(console.error(err.stack));
      }
    }
    return results;
  };

  WebSocketServer.prototype.modified = function(filename) {
    return this.send({
      type: 'modified',
      filename: filename
    });
  };

  return WebSocketServer;

})();

var WebSocketServer$1 = WebSocketServer;

// src/bebop.coffee
var Bebop;

Bebop = (function() {
  function Bebop(server1) {
    this.server = server1;
  }

  Bebop.prototype.attach = function(server, opts) {
    if (opts == null) {
      opts = {};
    }
    inject(server);
    return this.wss = new WebSocketServer$1({
      server: server
    });
  };

  Bebop.prototype.close = function() {
    return this.wss.close.apply(this.wss, arguments);
  };

  Bebop.prototype.send = function() {
    return this.wss.send.apply(this.wss, arguments);
  };

  Bebop.prototype.listen = function() {
    return this.server.listen.apply(server, arguments);
  };

  Bebop.prototype.reload = function(server, dir) {
    var wss;
    if (dir == null) {
      dir = process.cwd();
    }
    wss = this.attach(server);
    vigil.watch(dir, function(filename) {
      return this.wss.send({
        type: 'reload',
        filename: filename
      });
    });
    return wss;
  };

  return Bebop;

})();

var Bebop$1 = Bebop;

// src/middleware/fake-express.coffee
var fakeExpress = function(req, res, next) {
  var url$$1;
  res.redirect = function(loc) {
    res.writeHead(302, {
      Location: loc
    });
    return res.end();
  };
  res.set = function(headers) {
    var k, results, v;
    results = [];
    for (k in headers) {
      v = headers[k];
      results.push(res.setHeader(k, v));
    }
    return results;
  };
  res.send = function(body) {
    return res.end(body);
  };
  url$$1 = parse(req.url);
  req.path = url$$1.pathname;
  req.search = url$$1.search;
  return next();
};

// src/middleware/live-reload.coffee
var LiveReload;
var livereload;
var serveStatic$1;

serveStatic$1 = function(req, res, next) {
  var contentType, file;
  switch (path.extname(req.url)) {
    case '.js':
      contentType = 'application/javascript';
      break;
    case '.coffee':
      contentType = 'application/coffeescript';
      break;
    case '.map':
      contentType = 'application/json';
      break;
    default:
      next();
  }
  if (/^\/src\/node_modules/.test(req.url)) {
    req.url = req.url.substring(4);
  }
  file = path.join(__dirname, '/..', req.url);
  res.writeHead(200, {
    'Content-Type': contentType
  });
  return fs.createReadStream(file).pipe(res);
};

LiveReload = (function() {
  function LiveReload(opts) {
    if (opts == null) {
      opts = {};
    }
    this.js = "<script src=\"/bebop.min.js\"></script>\n<script>\n  var bebop = new Bebop(" + (JSON.stringify(opts)) + ");\n  bebop.debug = true;\n  bebop.connect();\n</script>";
  }

  LiveReload.prototype.injectJs = function(res) {
    var appendScript, end, setHeader;
    appendScript = false;
    end = res.end;
    setHeader = res.setHeader;
    res.setHeader = (function(_this) {
      return function(name, value) {
        if (/text\/html/i.test(value)) {
          appendScript = true;
        } else if (name === 'Content-Length' && appendScript) {
          value = parseInt(value, 10) + _this.js.length;
        }
        return setHeader.call(res, name, value);
      };
    })(this);
    return res.end = (function(_this) {
      return function(chunk, encoding) {
        if (appendScript) {
          res.write(_this.js, encoding);
        }
        return end.call(res, chunk, encoding);
      };
    })(this);
  };

  LiveReload.prototype.middleware = function(req, res, next) {
    if (/^\/bebop|src\/client\/bebop/.test(req.url)) {
      return serveStatic$1(req, res, next);
    }
    this.injectJs(res);
    return next();
  };

  return LiveReload;

})();

var liveReload = livereload = function(opts) {
  var r;
  if (opts == null) {
    opts = {};
  }
  r = new LiveReload(opts);
  return function liveReload(req, res, next) { return r.middleware(req, res, next); };
};

// src/middleware/node-modules-redirect.coffee
var nodeModulesRedirect;

var nodeModulesRedirect$1 = nodeModulesRedirect = function(req, res, next) {
  var nm;
  nm = req.path.indexOf('node_modules');
  if (~nm) {
    res.writeHead(301, {
      Location: "/" + (req.path.substr(nm))
    });
    return res.end();
  } else {
    return next();
  }
};

// src/middleware/strip-html.coffee
var stripHtml;
var trailingHtmlRe;

trailingHtmlRe = /\.html$/;

var stripHtml$1 = stripHtml = function(req, res, next) {
  var loc;
  if (!trailingHtmlRe.test(req.url)) {
    return next();
  }
  loc = req.url.replace(/index.html$/, '');
  loc = loc.replace(trailingHtmlRe, '');
  return res.redirect(loc);
};

// src/middleware/strip-slash.coffee
var stripSlash;
var trailingSlashRe;

trailingSlashRe = /\.html\/$/;

var stripSlash$1 = stripSlash = function(req, res, next) {
  var loc;
  if (!trailingSlashRe.test(req.url)) {
    return next();
  }
  loc = req.url.replace(trailingSlashRe, '.html');
  return res.redirect(loc);
};

// assets/github-markdown.css
var css = "";

// src/middleware/markdown.coffee
marked.setOptions({
  renderer: new marked.Renderer(),
  breaks: false,
  gfm: true,
  pedantic: false,
  sanitize: true,
  smartLists: true,
  smartypants: false,
  tables: true
});

var markdown = function(opts) {
  var maxAge;
  if (opts == null) {
    opts = {};
  }
  maxAge = opts.maxAge || 0;
  return function(req, res, next) {
    var path$$1, pathname;
    pathname = (url.parse(req.url, true, true)).pathname;
    if (!/\.md$/.test(pathname)) {
      return next();
    }
    path$$1 = pathname.replace(/^\//, '');
    return fs.exists(path$$1, function(exists) {
      var now;
      if (!exists) {
        return next();
      }
      now = new Date().toUTCString();
      res.setHeader('Content-Type', 'text/html; charset=UTF-8');
      if (!res.getHeader('Cache-Control')) {
        res.setHeader('Cache-Control', 'public, max-age=' + (maxAge / 1000));
      }
      if (!res.getHeader('Date')) {
        res.setHeader('Date', now);
      }
      if (!res.getHeader('Last-Modified')) {
        res.setHeader('Last-Modified', now);
      }
      if (req.method === 'HEAD') {
        res.writeHead(200);
        return res.end();
      }
      if (req.method !== 'GET') {
        return next();
      }
      return fs.readFile(path$$1, 'utf-8', function(err, data) {
        if (err != null) {
          throw err;
        }
        res.writeHead(200);
        return res.end("<html>\n  <head>\n    <title>" + path$$1 + "</title>\n    <style>\n    " + css + "\n    </style>\n  </head>\n  <body>\n  " + (marked(data)) + "\n  </body>\n</html>");
      });
    });
  };
};

// src/middleware/index.coffee



var index$2 = Object.freeze({
	fakeExpress: fakeExpress,
	liveReload: liveReload,
	markdown: markdown,
	nodeModulesRedirect: nodeModulesRedirect$1,
	stripHtml: stripHtml$1,
	stripSlash: stripSlash$1
});

// src/server.coffee
var Server;
var cacheControl;
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
var hasProp = {}.hasOwnProperty;

cacheControl = function(res, path$$1) {
  if ((serveStatic.mime.lookup(path$$1)) === 'text/html') {
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    return res.setHeader('Pragma', 'no-cache');
  }
};

Server = (function(superClass) {
  extend(Server, superClass);

  function Server(opts) {
    var app, dir, i, len, ref, ref1, ref2, ref3, serveOpts;
    if (opts == null) {
      opts = {};
    }
    if (opts.host == null) {
      opts.host = '0.0.0.0';
    }
    if (opts.port == null) {
      opts.port = 1987;
    }
    if (opts.buildDir == null) {
      opts.buildDir = process.cwd();
    }
    if (opts.workDir == null) {
      opts.workDir = process.cwd();
    }
    if (opts.hideIcon == null) {
      opts.hideIcon = false;
    }
    app = connect$1();
    app.use(fakeExpress);
    app.use(stripHtml$1);
    app.use(stripSlash$1);
    if (opts.hideIcon == null) {
      app.use(favicons(__dirname + '/../assets'));
    }
    app.use(logger('dev'));
    if (opts.user && opts.pass) {
      app.use(basicAuth(opts.user, opts.pass));
    }
    app.use(liveReload());
    app.use(markdown());
    serveOpts = {
      maxAge: '1d',
      setHeaders: cacheControl,
      etag: false,
      fallthrough: true,
      dotfiles: (ref = opts.dotfiles) != null ? ref : 'deny',
      extensions: (ref1 = opts.extensions) != null ? ref1 : ['html', 'htm'],
      index: (ref2 = opts.index) != null ? ref2 : ['index.html', 'index.htm']
    };
    app.use(serveStatic(opts.buildDir, serveOpts));
    app.use(serveIndex(opts.buildDir, {
      hidden: true
    }));
    app.use('/node_modules', serveStatic(process.cwd() + '/node_modules', serveOpts));
    app.use(nodeModulesRedirect$1);
    ref3 = [opts.assetDir, opts.workDir];
    for (i = 0, len = ref3.length; i < len; i++) {
      dir = ref3[i];
      if ((dir != null) && dir !== '' && dir !== opts.buildDir) {
        app.use(serveStatic(dir, serveOpts));
      }
    }
    Server.__super__.constructor.call(this, this.app = app);
    this.opts = opts;
  }

  Server.prototype.run = function(cb) {
    var host, port, ref, workDir;
    if (cb == null) {
      cb = function() {};
    }
    ref = this.opts, workDir = ref.workDir, host = ref.host, port = ref.port;
    this.once('listening', function() {
      var dir;
      dir = path.basename(workDir);
      if (host === '0.0.0.0') {
        host = firstAddress();
        log$1.bebop("serving " + dir + " at");
        console.log("    http://" + host + ":" + port);
        return console.log("    http://localhost:" + port);
      } else {
        return log$1.bebop("serving " + dir + " at http://" + host + ":" + port);
      }
    });
    process.once('uncaughtException', (function(_this) {
      return function(err) {
        if (err.code === 'EADDRINUSE') {
          log$1.error('address in use, retrying...');
          _this.close();
          _this.opts.port++;
          return setTimeout((function() {
            return _this.run();
          }), 1000);
        } else {
          return log$1.error(err);
        }
      };
    })(this));
    return this.listen(port, host, cb);
  };

  return Server;

})(http.Server);

var Server$1 = Server;

// src/index.coffee
var index = new Bebop$1;

export { Bebop$1 as Bebop, Server$1 as Server, WebSocketServer$1 as WebSocketServer, index$1 as compilers, index$2 as middleware };export default index;
//# sourceMappingURL=bebop.mjs.map
