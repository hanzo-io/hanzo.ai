import path, { extname } from 'path';
import { rollup as rollup$1 } from 'rollup';
import chalk from 'chalk';
import fs from 'fs';
import commonjs from 'rollup-plugin-commonjs';
import es3 from 'rollup-plugin-es3';
import inject from 'rollup-plugin-inject';
import legacy from 'rollup-plugin-legacy';
import nodeResolve from 'rollup-plugin-node-resolve-magic';
import sizes from 'rollup-plugin-sizes';
import sourcemaps from 'rollup-plugin-sourcemaps';
import magic from 'magic-string';
import builtins from 'rollup-plugin-node-builtins';
import fileSize from 'filesize';
import gzip from 'gzip-size';
import globals from 'rollup-plugin-node-globals';
import typescript from 'rollup-plugin-typescript';
import json from 'rollup-plugin-json';
import pug from 'rollup-plugin-pug';
import string from 'rollup-plugin-string';
import stylup from 'rollup-plugin-stylup';
import autoprefixer from 'autoprefixer';
import cssnano from 'cssnano';
import lost from 'lost';
import lostStylus from 'lost-stylus';
import postcss from 'poststylus';
import rupture from 'rupture';

// src/colors.coffee
var gray;
var white;

gray = function(s) {
  return chalk.gray(s);
};

gray.bold = function(s) {
  return chalk.gray.bold(s);
};

white = function(s) {
  return chalk.white(s);
};

white.bold = function(s) {
  return chalk.white.bold(s);
};

white.dim = function(s) {
  return chalk.white.dim(s);
};

// src/log.coffee
var log;
var verbose;

verbose = true;

log = function() {
  if (verbose) {
    return console.log.apply(console, arguments);
  }
};

log.warn = function() {
  if (verbose) {
    return console.log.apply(console, arguments);
  }
};

log.error = function() {
  return console.error.apply(console, arguments);
};

log.verbose = function(bool) {
  return verbose = bool;
};

log.gray = function(message) {
  return log(gray(message));
};

log.white = function(message) {
  return log(white(message));
};

log.white.bold = function(message) {
  return log(white.bold(message));
};

log.white.dim = function(message) {
  return log(white.dim(message));
};

var log$1 = log;

// node_modules/es-object-assign/lib/es-object-assign.mjs
// src/index.coffee
var getOwnSymbols;
var objectAssign;
var shouldUseNative;
var toObject;
var slice = [].slice;

getOwnSymbols = Object.getOwnPropertySymbols;

toObject = function(val) {
  if (val === null || val === void 0) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }
  return Object(val);
};

shouldUseNative = function() {
  var err, i, j, k, len, letter, order2, ref, test1, test2, test3;
  try {
    if (!Object.assign) {
      return false;
    }
    test1 = new String('abc');
    test1[5] = 'de';
    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    }
    test2 = {};
    for (i = j = 0; j <= 9; i = ++j) {
      test2['_' + String.fromCharCode(i)] = i;
    }
    order2 = Object.getOwnPropertyNames(test2).map(function(n) {
      return test2[n];
    });
    if (order2.join('') !== '0123456789') {
      return false;
    }
    test3 = {};
    ref = 'abcdefghijklmnopqrst'.split('');
    for (k = 0, len = ref.length; k < len; k++) {
      letter = ref[k];
      test3[letter] = letter;
    }
    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }
    return true;
  } catch (error) {
    err = error;
    return false;
  }
};

var index = objectAssign = (function() {
  if (shouldUseNative()) {
    return Object.assign;
  }
  return function() {
    var from, j, k, key, len, len1, ref, source, sources, symbol, target, to;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    to = toObject(target);
    for (j = 0, len = sources.length; j < len; j++) {
      source = sources[j];
      from = Object(source);
      for (key in from) {
        if (Object.prototype.hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }
      if (getOwnSymbols) {
        ref = getOwnSymbols(from);
        for (k = 0, len1 = ref.length; k < len1; k++) {
          symbol = ref[k];
          if (Object.prototype.propIsEnumerable.call(from, symbol)) {
            to[symbol] = from[symbol];
          }
        }
      }
    }
    return to;
  };
})();

// package.json
var name = "handroll";
var version = "0.14.11";
var description = "Expertly rolled JavaScript. API + CLI for for bundling opinionated JavaScript with Rollup.js";
var homepage = "http://github.com/zeekay/handroll";
var bugs = "http://github.com/zeekay/handroll/issues";
var keywords = ["bundler","bundling","es6","handroll","modules","preprocessor","rollup"];
var bin = "bin/handroll";
var main = "lib/handroll.js";
var module$1 = "lib/handroll.mjs";
var files = ["bin/handroll","lib/","src/"];
var engines = {"node":">=4.0.0"};
var scripts = {"build":"sake build","prepublishOnly":"sake build","pretest":"sake build","test":"sake test"};
var license = "MIT";
var repository = {"type":"git","url":"http://github.com/zeekay/handroll"};
var dependencies = {"autoprefixer":"7.1.1","chalk":"1.1.3","cssnano":"3.10.0","filesize":"3.5.10","gzip-size":"3.0.0","lost":"8.0.0","lost-stylus":"^0.1.3","magic-string":"0.20.0","poststylus":"0.2.3","rollup":"0.41.6","rollup-plugin-commonjs":"8.0.2","rollup-plugin-es3":"1.0.3","rollup-plugin-inject":"2.0.0","rollup-plugin-json":"2.1.1","rollup-plugin-legacy":"1.0.0","rollup-plugin-node-builtins":"2.1.2","rollup-plugin-node-globals":"1.1.0","rollup-plugin-node-resolve-magic":"^0.2.6","rollup-plugin-pug":"0.1.3","rollup-plugin-sizes":"0.3.0","rollup-plugin-sourcemaps":"0.4.2","rollup-plugin-string":"2.0.2","rollup-plugin-strip":"1.1.1","rollup-plugin-stylup":"1.3.4","rollup-plugin-typescript":"0.8.1","rupture":"0.6.2","uglify-es":"^3.0.10"};
var devDependencies = {"coffee-script":"1.12.6","es-object-assign":"^4.1.4","rollup-plugin-coffee2":"^0.1.10","rollup-plugin-executable":"1.0.0","sake-cli":"^0.5.17","sake-outdated":"^0.1.27","sake-publish":"^0.1.16","sake-version":"^0.1.19","stylus":"0.54.5"};
var pkg = {
	name: name,
	version: version,
	description: description,
	homepage: homepage,
	bugs: bugs,
	keywords: keywords,
	bin: bin,
	main: main,
	module: module$1,
	files: files,
	engines: engines,
	scripts: scripts,
	license: license,
	repository: repository,
	dependencies: dependencies,
	devDependencies: devDependencies
};

// src/utils.coffee
var hasProp = {}.hasOwnProperty;

var merge = function(fn) {
  return function(opts) {
    opts = index({}, this.opts, opts);
    if (opts.quiet != null) {
      log$1.verbose(!opts.quiet);
    }
    return fn.call(this, opts);
  };
};

var moduleName = function(name$$1) {
  var first;
  if (!name$$1.trim()) {
    return '';
  }
  first = name$$1.charAt(0).toUpperCase();
  name$$1 = name$$1.replace(/\.js$|\.coffee$|-js$/, '');
  name$$1 = name$$1.replace(/-([a-z])/g, function(g) {
    return g[1].toUpperCase();
  });
  return first + name$$1.slice(1);
};

var isPlugin = (function() {
  var keys;
  keys = new Set(['name', 'options', 'load', 'resolveId', 'transform', 'transformBundle', 'ongenerate', 'onwrite', 'intro', 'outro', 'banner', 'footer']);
  return function(obj) {
    var k;
    for (k in obj) {
      if (!hasProp.call(obj, k)) continue;
      if (keys.has(k)) {
        return true;
      }
    }
    return false;
  };
})();

var banner = function() {
  if (banner.seen == null) {
    log$1.white.dim("handroll v" + version + " üç£");
    return banner.seen = true;
  }
};

var isArray = function(v) {
  return Array.isArray(v);
};

var isString = function(v) {
  return typeof v === 'string' || v instanceof String;
};

// src/external.coffee
var detectExternal;
var logExternals;
var logIncluded;
var removeIncluded;

var getDeps = function(pkg, dev) {
  var deps, devDeps, peerDeps, ref, ref1, ref2;
  if (dev == null) {
    dev = false;
  }
  deps = Object.keys((ref = pkg.dependencies) != null ? ref : {});
  devDeps = Object.keys((ref1 = pkg.devDependencies) != null ? ref1 : {});
  peerDeps = Object.keys((ref2 = pkg.peerDependencies) != null ? ref2 : {});
  deps = deps.concat(peerDeps);
  if (dev) {
    return deps.concat(devDeps);
  } else {
    return deps;
  }
};

detectExternal = function(external, pkg) {
  if (external === true || (external == null)) {
    external = getDeps(pkg);
  }
  if (external === 'dev') {
    external = getDeps(pkg, true);
  }
  if (external === false) {
    external = [];
  }
  return external;
};

removeIncluded = function(externals, include) {
  var dep, i, idx, len, removed;
  if (include == null) {
    include = [];
  }
  removed = [];
  for (i = 0, len = include.length; i < len; i++) {
    dep = include[i];
    if (~(idx = externals.indexOf(dep))) {
      externals.splice(idx, 1);
      removed.push(dep);
    }
  }
  return removed;
};

logExternals = function(externals) {
  var dep, i, len;
  if (externals.length) {
    log$1('external:');
    for (i = 0, len = externals.length; i < len; i++) {
      dep = externals[i];
      log$1(" - " + dep);
    }
  } else {
    log$1('no externals');
  }
};

logIncluded = function(included) {
  var dep, i, len;
  if (included.length) {
    log$1('included:');
    for (i = 0, len = included.length; i < len; i++) {
      dep = included[i];
      log$1(" + " + dep);
    }
  }
};

var autoExternal = function(arg) {
  var external, externals, include, included, pkg;
  external = arg.external, include = arg.include, pkg = arg.pkg;
  if (isArray(external)) {
    return external;
  }
  externals = detectExternal(external, pkg);
  included = removeIncluded(externals, include);
  logExternals(externals);
  logIncluded(included);
  return externals;
};

// src/formats.coffee
var autoFormats = function(arg) {
  var format, formats, pkg;
  format = arg.format, formats = arg.formats, pkg = arg.pkg;
  if (format != null) {
    return [format];
  } else if (formats != null) {
    return formats;
  } else {
    formats = [];
    if (pkg.browser != null) {
      formats.push('web');
    }
    if (pkg.main != null) {
      formats.push('cjs');
    }
    if (pkg.module != null) {
      formats.push('es');
    }
    return formats;
  }
};

var detectFormats = function(opts) {
  if (opts.format != null) {
    return [opts.format];
  } else if (opts.formats != null) {
    return opts.formats;
  } else {
    return autoFormats(opts);
  }
};

var formatOpts = function(opts) {
  if (opts.format == null) {
    opts.format = 'es';
  }
  switch (opts.format) {
    case 'app':
      return app(opts);
    case 'cli':
    case 'bin':
    case 'binary':
    case 'executable':
      return cli(opts);
    case 'cjs':
    case 'commonjs':
    case 'node':
      return cjs(opts);
    case 'es':
    case 'module':
      return es(opts);
    case 'umd':
      return umd(opts);
    case 'web':
    case 'iife':
      return web(opts);
    default:
      throw new Error('Unsupported export format');
  }
};

var app = function(opts) {
  var dest, ref, ref1, ref2, ref3, stat;
  dest = (ref = (ref1 = opts.dest) != null ? ref1 : (ref2 = opts.pkg) != null ? ref2.app : void 0) != null ? ref : (ref3 = opts.pkg) != null ? ref3.main : void 0;
  stat = fs.statSync(dest);
  if (stat.isDirectory()) {
    dest = path.join(dest, 'app.js');
  }
  return {
    dest: dest,
    format: 'iife',
    sourceMap: opts.sourceMap
  };
};

var es = function(opts) {
  var dest, ref, ref1, ref2, ref3, ref4;
  dest = (ref = (ref1 = (ref2 = opts.dest) != null ? ref2 : (ref3 = opts.pkg) != null ? ref3.module : void 0) != null ? ref1 : (ref4 = opts.pkg) != null ? ref4['js:next'] : void 0) != null ? ref : null;
  return {
    dest: dest,
    format: 'es',
    sourceMap: opts.sourceMap
  };
};

var cjs = function(opts) {
  var dest, ref, ref1, ref2;
  dest = (ref = (ref1 = opts.dest) != null ? ref1 : (ref2 = opts.pkg) != null ? ref2.main : void 0) != null ? ref : null;
  return {
    dest: dest,
    format: 'cjs',
    sourceMap: opts.sourceMap
  };
};

var cli = function(opts) {
  var dest, ref, ref1, ref2, ref3;
  dest = (ref = (ref1 = opts.dest) != null ? ref1 : (ref2 = opts.pkg) != null ? ref2.bin : void 0) != null ? ref : path.join('bin/', (moduleName((ref3 = opts.pkg) != null ? ref3.name : void 0)).toLowerCase());
  if (!isString(dest)) {
    dest = dest[(Object.keys(dest))[0]];
  }
  return {
    dest: dest,
    executable: true,
    format: 'cjs',
    sourceMap: opts.sourceMap
  };
};

var web = function(opts) {
  var dest, name, ref, ref1, ref2;
  name = (ref = opts.moduleName) != null ? ref : moduleName((ref1 = opts.pkg) != null ? ref1.name : void 0);
  dest = (ref2 = opts.dest) != null ? ref2 : (name + ".js").toLowerCase();
  return {
    dest: dest,
    browser: opts.browser !== false,
    external: false,
    format: 'iife',
    moduleName: name,
    sourceMap: opts.sourceMap
  };
};

var umd = function(opts) {
  return {
    dest: opts.dest,
    format: 'umd',
    sourceMap: opts.sourceMap
  };
};

// node_modules/rollup-plugin-executable/lib/node.esmodule.js
/*! rollup-plugin-executable v1.0.0 by undefined */
// eslint-disable-next-line filenames/match-exported
// Set EXECUTABLE bit on file mode
var EXECUTABLE_MODE = 73;

function executable() {
  0 < arguments.length && arguments[0] !== undefined ? arguments[0] : {};

  return {
    name: "rollup-plugin-executable",

    onwrite: function onwrite(_ref) {
      var dest = _ref.dest,
          _fs$statSync = fs.statSync(dest),
          mode = _fs$statSync.mode;

      // eslint-disable-next-line no-bitwise


      fs.chmodSync(dest, mode | EXECUTABLE_MODE);
    }
  };
}

// src/plugins/annotate.coffee
var annotate = function(opts) {
  if (opts == null) {
    opts = {};
  }
  return {
    name: 'annotate',
    transform: function(source, id) {
      var filename, ms, result;
      filename = path.relative(process.cwd(), id);
      ms = (new magic(source)).prepend("// " + filename + "\n");
      result = {
        code: ms.toString()
      };
      if (opts.sourceMap) {
        result.map = ms.generateMap({
          hires: true
        });
      }
      return result;
    }
  };
};

// src/plugins/builtins.coffee
var builtins$1 = function(opts) {
  var plugin;
  if (opts == null) {
    opts = {};
  }
  plugin = builtins(opts);
  plugin.name = 'node-builtins';
  return plugin;
};

// src/plugins/filesize.coffee
var render;

render = function(filename, size, gzipSize) {
  var gb, wb;
  gb = chalk.green.bold;
  wb = chalk.white.bold;
  return " ‚á¢ " + (wb(filename)) + "\t" + (gb(size)) + " (" + (gb(gzipSize)) + " compressed)";
};

var filesize = function(opts) {
  if (opts == null) {
    opts = {};
  }
  if (opts.format == null) {
    opts.format = {};
  }
  return {
    name: 'filesize',
    ongenerate: function(bundle, result) {
      var gzipSize, size;
      size = fileSize(Buffer.byteLength(result.code, opts.format));
      gzipSize = fileSize(gzip.sync(result.code), opts.format);
      return console.log(render(bundle.dest, size, gzipSize));
    }
  };
};

// src/plugins/globals.coffee
var globals$1 = function(opts) {
  var plugin;
  if (opts == null) {
    opts = {};
  }
  plugin = globals(opts);
  plugin.name = 'node-globals';
  return plugin;
};

// src/plugins/minify.coffee
var minify = function(opts) {
  var minify;
  if (opts == null) {
    opts = {};
  }
  minify = require('uglify-es').minify;
  console.log(opts);
  return {
    name: 'minify',
    transformBundle: function(code, plugins, sourceMapChain, options) {
      var ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, result;
      result = minify(code, {
        compress: (ref = opts.compress) != null ? ref : {},
        ie8: (ref1 = opts.ie8) != null ? ref1 : false,
        keep_fnames: (ref2 = (ref3 = opts.keepFnames) != null ? ref3 : opts.keep_fnames) != null ? ref2 : false,
        mangle: (ref4 = opts.mangle) != null ? ref4 : {},
        output: (ref5 = opts.output) != null ? ref5 : {},
        parse: (ref6 = opts.parse) != null ? ref6 : {},
        sourceMap: (ref7 = opts.sourceMap) != null ? ref7 : false,
        toplevel: (ref8 = opts.toplevel) != null ? ref8 : false,
        warnings: (ref9 = opts.warnings) != null ? ref9 : false,
        wrap: (ref10 = opts.wrap) != null ? ref10 : false
      });
      return result;
    }
  };
};

// src/plugins/shebang.coffee
var shebang = function(opts) {
  if (opts == null) {
    opts = {};
  }
  return {
    name: 'shebang',
    banner: '#!/usr/bin/env node'
  };
};

// node_modules/rollup-plugin-coffee2/lib/rollup-plugin-coffee2.mjs
// src/format-error.coffee
var formatError = function(source, filename, err) {
  var carets, col, first_column, first_line, l, last_column, last_line, lines, ref;
  ref = err.location, first_line = ref.first_line, last_line = ref.last_line, first_column = ref.first_column, last_column = ref.last_column;
  if (last_line == null) {
    last_line = first_line;
  }
  lines = source.split('\n');
  l = lines[first_line];
  lines[first_line] = (l.substring(0, first_column)) + '\x1B[91m' + l.substring(first_column);
  l = lines[last_line];
  if (first_line === last_line) {
    col = last_column + 6;
  } else {
    col = last_column;
  }
  lines[last_line] = (l.substring(0, col)) + '\x1B[39m' + (l.substring(col));
  lines = lines.slice(first_line, last_line + 1);
  carets = Array(first_column + 1).join(' ') + ("\x1B[91m" + (Array(last_column + 2 - first_column).join('^')) + "\x1B[39m");
  lines.push(carets);
  return filename + ":" + (first_line + 1) + ":" + (first_column + 1) + ": " + err.name + ": " + err.message + "\n" + (lines.join('\n')) + "\n";
};

// src/index.coffee
var findCoffee;
var findEither;
var sourceMap;
var version$1;

version$1 = function(coffee) {
  return parseInt((coffee.VERSION.split('.'))[0], 10);
};

findCoffee = function(wanted) {
  var coffee, err, i, len, pkg, ref;
  ref = ['coffeescript', 'coffee-script'];
  for (i = 0, len = ref.length; i < len; i++) {
    pkg = ref[i];
    try {
      coffee = require(pkg);
      if ((version$1(coffee)) === wanted) {
        return coffee;
      }
    } catch (error) {
      err = error;
    }
  }
  throw new Error('Unable to find CoffeeScript matching version ' + wanted);
};

findEither = function() {
  var coffee, err;
  try {
    return coffee = findCoffee(2);
  } catch (error) {
    err = error;
    return coffee = findCoffee(1);
  }
};

sourceMap = function(out) {
  if (out.v3SourceMap) {
    return JSON.parse(out.v3SourceMap);
  } else {
    return null;
  }
};

var index$1 = function(opts) {
  var coffee;
  if (opts == null) {
    opts = {};
  }
  if (opts.sourceMap == null) {
    opts.sourceMap = true;
  }
  if (opts.bare == null) {
    opts.bare = true;
  }
  if (opts.extensions == null) {
    opts.extensions = ['.coffee', '.litcoffee'];
  }
  if (opts.version != null) {
    coffee = findCoffee(opts.version);
  } else {
    coffee = findEither();
  }
  return {
    name: 'coffee2',
    transform: function(code, id) {
      var err, out;
      if (opts.extensions.indexOf(extname(id)) === -1) {
        return null;
      }
      try {
        out = coffee.compile(code, {
          filename: id,
          bare: opts.bare,
          sourceMap: opts.sourceMap
        });
      } catch (error) {
        err = error;
        if (err.location != null) {
          err.formattedMessage = formatError(code, id, err);
        }
        throw err;
      }
      return {
        code: out.js,
        map: sourceMap(out)
      };
    }
  };
};

// src/compilers.coffee
var autoCompilers = function(opts) {
  var coffeeOpts, compilers, jsonOpts, k, postPlugins, pugOpts, ref, ref1, ref2, ref3, ref4, ref5, stylusOpts, typescriptOpts, v;
  postPlugins = [
    lost(), autoprefixer({
      browsers: '> 1%'
    })
  ];
  if (opts.minify) {
    postPlugins.push(cssnano());
  }
  coffeeOpts = index({}, (ref = opts.compilers) != null ? ref.coffee : void 0);
  typescriptOpts = index({}, (ref1 = opts.compilers) != null ? ref1.typescript : void 0);
  jsonOpts = index({}, (ref2 = opts.compilers) != null ? ref2.json : void 0);
  pugOpts = index({}, {
    compileDebug: false,
    inlineRuntimeFunctions: false,
    pretty: opts.minify ? false : true,
    sourceMap: opts.sourceMap,
    staticPattern: /\S/
  }, (ref3 = opts.compilers) != null ? ref3.pug : void 0);
  stylusOpts = index({}, {
    sourceMap: opts.sourceMap,
    plugins: [lostStylus(), rupture(), postcss(postPlugins)]
  }, (ref4 = opts.compilers) != null ? ref4.stylus : void 0);
  compilers = {
    coffee: index$1(coffeeOpts),
    css: string({
      include: '**/*.css'
    }),
    html: string({
      include: '**/*.html'
    }),
    json: json(jsonOpts),
    pug: pug(pugOpts),
    stylus: stylup(stylusOpts),
    typescript: typescript(typescriptOpts)
  };
  compilers.css.name = 'string-css';
  compilers.html.name = 'string-html';
  compilers.typescript.name = 'typescript';
  ref5 = opts.compilers;
  for (k in ref5) {
    v = ref5[k];
    if (isPlugin(v)) {
      compilers[k] = v;
    }
  }
  return compilers;
};

// src/plugins.coffee
var resolveId;

resolveId = function(id, opts) {
  if (opts == null) {
    opts = {};
  }
  if (opts.browser) {
    return nodeResolve.browser.sync(id, {
      basedir: opts.basedir
    });
  } else {
    return nodeResolve.node.sync(id, {
      basedir: opts.basedir
    });
  }
};

var autoPlugins = function(opts) {
  var err, i, k, len, name, plugin, plugins, ref, ref1, ref2, ref3, ref4, ref5, v;
  plugins = [sourcemaps()];
  if (opts.plugins != null) {
    plugins = plugins.concat(opts.plugins);
  } else {
    ref = autoCompilers(opts);
    for (k in ref) {
      v = ref[k];
      plugins.push(v);
    }
  }
  plugins = plugins.concat((ref1 = opts.use) != null ? ref1 : []);
  plugins.push(annotate({
    sourceMap: opts.sourceMap
  }));
  if (opts.legacy != null) {
    ref2 = opts.legacy;
    for (k in ref2) {
      v = ref2[k];
      try {
        opts.legacy[resolveId(k, opts)] = v;
      } catch (error) {
        err = error;
      }
    }
    plugins.push(legacy(opts.legacy));
  }
  if (opts.browser || opts.node) {
    plugins.push(globals$1());
    plugins.push(builtins$1());
  }
  plugins.push(nodeResolve({
    basedir: opts.basedir,
    browser: opts.browser,
    extensions: opts.extensions,
    preferBuiltins: opts.preferBuiltins,
    external: (ref3 = opts.autoExternal) != null ? ref3 : true,
    skip: (ref4 = opts.skip) != null ? ref4 : opts.external
  }));
  if (opts.browser || opts.es3) {
    if (opts.es3 !== false) {
      plugins.push(es3());
    }
  }
  if (opts.commonjs) {
    plugins.push(commonjs(index({
      extensions: opts.extensions,
      sourceMap: opts.sourceMap
    }, opts.commonjs)));
  }
  if (opts.inject != null) {
    plugins.push(inject(opts.inject));
  }
  if (opts.executable) {
    plugins.push(shebang());
    plugins.push(executable());
  }
  if (opts.strip) {
    plugins.push(strip({
      "debugger": true,
      functions: ['console.log', 'assert.*', 'debug', 'alert'],
      sourceMap: opts.sourceMap
    }));
  }
  if ((opts.minify != null) && !opts.minify === false) {
    plugins.push(minify(index({}, {
      sourceMap: opts.sourceMap
    }, opts.minify)));
  }
  if (!opts.quiet) {
    plugins.push(filesize());
    if (opts.details) {
      plugins.push(sizes({
        details: true
      }));
    }
  }
  log$1('plugins:');
  for (i = 0, len = plugins.length; i < len; i++) {
    plugin = plugins[i];
    name = ((ref5 = plugin.name) != null ? ref5 : '').replace(/rollup-plugin-/, '');
    log$1(" + " + name);
  }
  return plugins;
};

// src/generate.coffee
var generate = function(bundle, opts) {
  return bundle.generate(formatOpts(opts));
};

// src/write.coffee
var write = function(bundle, opts) {
  switch (opts.format) {
    case 'app':
      return bundle.write(writeApp(opts));
    default:
      return bundle.write(formatOpts(opts));
  }
};

var writeAll = function(bundle, opts) {
  var fmt, i, len, ps, ref;
  ps = [];
  ref = detectFormats(opts);
  for (i = 0, len = ref.length; i < len; i++) {
    fmt = ref[i];
    ps.push(write(bundle, index({}, opts, {
      format: fmt
    })));
  }
  return Promise.all(ps);
};

var writeApp = function(opts) {
  opts = formatOpts(opts);
  fs.writeFileSync(path.join(opts.basedir, 'index.html'), "<!DOCTYPE html>\n<html lang=\"en\">\n  <body>\n    <script src=\"" + opts.dest + "\"></script>\n  </body>\n</html>");
  return opts;
};

// src/bundle.coffee
var Bundle;
var cached;
var readPkg;

cached = null;

readPkg = function() {
  var err;
  try {
    return require(path.join(process.cwd(), 'package.json'));
  } catch (error) {
    err = error;
    return {};
  }
};

Bundle = (function() {
  function Bundle(opts) {
    var ref;
    if (opts == null) {
      opts = {};
    }
    if (!(this instanceof Bundle)) {
      return new Bundle(opts);
    }
    if (opts.pkg == null) {
      opts.pkg = readPkg();
    }
    if (opts.acorn == null) {
      opts.acorn = {
        allowReserved: true
      };
    }
    if (opts.browser == null) {
      opts.browser = false;
    }
    if (opts.compilers == null) {
      opts.compilers = null;
    }
    if (opts.es3 == null) {
      opts.es3 = false;
    }
    if (opts.executable == null) {
      opts.executable = false;
    }
    if (opts.extensions == null) {
      opts.extensions = ['.js', '.coffee', '.pug', '.styl'];
    }
    if (opts.sourceMap == null) {
      opts.sourceMap = true;
    }
    if (opts.external == null) {
      opts.external = null;
    }
    if (opts.include == null) {
      opts.include = [];
    }
    if (opts.inject == null) {
      opts.inject = null;
    }
    if (opts.plugins == null) {
      opts.plugins = null;
    }
    if (opts.use == null) {
      opts.use = [];
    }
    log$1.verbose(!((ref = opts.quiet) != null ? ref : false));
    this.opts = opts;
  }

  Bundle.prototype.cache = function(arg) {
    var cache, i, id, invalidate, len;
    cache = arg.cache, invalidate = arg.invalidate;
    if (cache === false) {
      return null;
    }
    if (cache == null) {
      cache = cached;
    }
    if (invalidate != null) {
      for (i = 0, len = invalidate.length; i < len; i++) {
        id = invalidate[i];
        log$1("removing " + id + " from module cache");
        delete cache[id];
      }
    }
    return cache;
  };

  Bundle.prototype.rollup = merge(function(opts) {
    var k, ref, ref1, ref2, v;
    if (!((opts.entry != null) && opts.entry !== '')) {
      throw new Error('No entry module specified');
    }
    banner();
    if (this.bundle != null) {
      log$1('using cached bundle');
      return Promise.resolve(this.bundle);
    }
    opts.autoExternal = (ref = opts.autoExternal) != null ? ref : opts.external === true;
    opts.basedir = (ref1 = opts.basedir) != null ? ref1 : path.dirname(opts.entry);
    opts.formats = autoFormats(opts);
    if (opts.formats.length === 1) {
      opts.format = opts.formats[0];
    }
    if (opts.format != null) {
      ref2 = formatOpts(opts);
      for (k in ref2) {
        v = ref2[k];
        opts[k] = v;
      }
    }
    opts.external = autoExternal(opts);
    opts.plugins = autoPlugins(opts);
    return new Promise((function(_this) {
      return function(resolve, reject) {
        return rollup$1({
          entry: opts.entry,
          cache: _this.cache(opts),
          acorn: opts.acorn,
          external: opts.external,
          plugins: opts.plugins,
          sourceMap: opts.sourceMap,
          onwarn: function(warning) {
            if (warning.code === 'UNRESOLVED_IMPORT') {
              return;
            }
            if (opts.onwarn != null) {
              return opts.onwarn(warning);
            }
            return log$1.warn(warning.message);
          }
        }).then(function(bundle) {
          if (opts.cacheBundle) {
            _this.bundle = bundle;
          }
          resolve(bundle);
          return log$1.white.bold(opts.entry);
        })["catch"](function(err) {
          var ref3;
          if (((ref3 = err.loc) != null ? ref3.file : void 0) != null) {
            log$1("\nFailed to parse '" + err.loc.file + "'");
            if (err.frame != null) {
              log$1("\n" + err.frame + "\n");
            }
          } else if ((err.plugin != null) && (err.id != null)) {
            log$1("\nPlugin '" + err.plugin + "' failed on module " + err.id);
            log$1(err.stack);
          } else if (err.id != null) {
            log$1("\nFailed to parse module " + err.id);
            log$1(err.stack);
          } else {
            log$1(err.stack);
          }
          return reject(err);
        });
      };
    })(this));
  });

  Bundle.prototype.generate = merge(function(opts) {
    return new Promise((function(_this) {
      return function(resolve, reject) {
        return _this.rollup(opts).then(function(bundle) {
          return resolve(generate(bundle, opts));
        })["catch"](reject);
      };
    })(this));
  });

  Bundle.prototype.write = merge(function(opts) {
    return new Promise((function(_this) {
      return function(resolve, reject) {
        return _this.rollup(opts).then(function(bundle) {
          if (opts.format != null) {
            return resolve(write(bundle, opts));
          } else {
            return resolve(writeAll(bundle, opts));
          }
        })["catch"](reject);
      };
    })(this));
  });

  return Bundle;

})();

var Bundle$1 = Bundle;

// src/handroll.coffee
var Handroll;
var sourceMapOverride;

sourceMapOverride = function() {
  if (process.env.DISABLE_SOURCEMAP) {
    return false;
  }
  if (process.env.NO_SOURCEMAP) {
    return false;
  }
  if (process.env.SOURCEMAP) {
    return true;
  }
  return null;
};

Handroll = (function() {
  function Handroll(opts) {
    var ref, ref1;
    if (opts == null) {
      opts = {};
    }
    if (!(this instanceof Handroll)) {
      return new Handroll(opts);
    }
    if (opts.sourceMap == null) {
      opts.sourceMap = (ref = sourceMapOverride()) != null ? ref : true;
    }
    log$1.verbose(!((ref1 = opts.quiet) != null ? ref1 : false));
    this.opts = opts;
  }

  Handroll.prototype.use = function(plugin) {
    var i, len, plugins;
    if (isArray(plugin)) {
      plugins = plugin;
    } else {
      plugins = [plugin];
    }
    for (i = 0, len = plugins.length; i < len; i++) {
      plugin = plugins[i];
      this.opts.use.push(plugin);
    }
    return this;
  };

  Handroll.prototype.bundle = merge(function(opts) {
    var bundle;
    bundle = new Bundle$1(opts);
    return new Promise(function(resolve, reject) {
      return (bundle.rollup({
        cacheBundle: true
      })).then(function() {
        return resolve(bundle);
      });
    });
  });

  Handroll.prototype.generate = merge(function(opts) {
    return (new Bundle$1(opts)).generate();
  });

  Handroll.prototype.write = merge(function(opts) {
    return (new Bundle$1(opts)).write();
  });

  return Handroll;

})();

var Handroll$1 = Handroll;

// src/index.coffee
var handroll;

handroll = new Handroll$1();

handroll.Bundle = Bundle$1;

handroll.Handroll = Handroll$1;

handroll.verbose = log$1.verbose;

handroll.version = pkg.version;

var handroll$1 = handroll;

export default handroll$1;
//# sourceMappingURL=handroll.mjs.map
