import fs from 'fs';
import path from 'path';
import semver from 'semver';

// src/outdated.coffee
var outdated = function() {
  return new Promise(function(resolve, reject) {
    return exec.quiet('npm outdated --json').then(function(arg) {
      var deps, k, outdated, ref, stdout, v;
      stdout = arg.stdout;
      if (stdout === '') {
        return resolve(null);
      }
      deps = JSON.parse(stdout);
      outdated = [];
      for (k in deps) {
        v = deps[k];
        if (v.latest === 'MISSING') {
          return reject(new Error('Missing dependencies'));
        }
        if (v.wanted && v.latest === 'git') {
          continue;
        }
        if ((v.wanted === (ref = v.latest) && ref === 'linked')) {
          continue;
        }
        if (semver.gt(v.current, v.wanted)) {
          outdated.push({
            name: k,
            current: v.current,
            wanted: v.wanted
          });
        }
      }
      if (outdated.length) {
        return resolve(outdated);
      } else {
        return resolve(null);
      }
    })["catch"](function(err) {
      return reject(err);
    });
  });
};

// src/index.coffee
var index = function(opts) {
  if (opts == null) {
    opts = {};
  }
  task('version:major', 'increment major version', ['version'], function() {});
  task('version:minor', 'increment minor version', ['version'], function() {});
  task('version:patch', 'increment patch version', ['version'], function() {});
  return task('version', 'change version of project', function*(opts) {
    var data, dep, deps, dir, i, len, level, major, minor, n, newVersion, patch, pkg, pkgPath, readmePath, ref, ref1, stderr, stdout, version;
    ref = (yield exec.quiet('git status --porcelain')), stdout = ref.stdout, stderr = ref.stderr;
    if (stderr || stdout) {
      console.log('working directory not clean');
      process.exit(1);
    }
    if ((deps = (yield outdated())) != null) {
      for (i = 0, len = deps.length; i < len; i++) {
        dep = deps[i];
        console.error(dep.name + " " + dep.current + " is installed but " + dep.wanted + " is specified in package.json");
      }
      process.exit(1);
    }
    if ((opts.before != null) && tasks.has(opts.before)) {
      yield invoke(opts.before);
    }
    dir = process.cwd();
    pkgPath = path.join(dir, 'package.json');
    readmePath = path.join(dir, 'README.md');
    pkg = require(pkgPath);
    version = pkg.version;
    level = (opts["arguments"].filter(function(v) {
      return v !== 'version';
    }))[0];
    ref1 = (function() {
      var j, len1, ref1, results;
      ref1 = version.split('.');
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        n = ref1[j];
        results.push(parseInt(n));
      }
      return results;
    })(), major = ref1[0], minor = ref1[1], patch = ref1[2];
    switch (level) {
      case 'version:major':
      case 'major':
        newVersion = (major + 1) + ".0.0";
        break;
      case 'version:minor':
      case 'minor':
        newVersion = major + "." + (minor + 1) + ".0";
        break;
      case 'version:patch':
      case 'patch':
        newVersion = major + "." + minor + "." + (patch + 1);
        break;
      default:
        console.log('Unable to parse versioning');
        process.exit(1);
    }
    console.log("v" + version + " -> v" + newVersion);
    console.log;
    data = fs.readFileSync(readmePath, 'utf8');
    data = data.replace(new RegExp(version, 'g'), newVersion);
    fs.writeFileSync(readmePath, data, 'utf8');
    pkg.version = newVersion;
    fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2), 'utf8');
    return (yield exec("git add .\ngit commit -m " + newVersion + "\ngit tag v" + newVersion));
  });
};

export default index;
//# sourceMappingURL=sake-version.mjs.map
