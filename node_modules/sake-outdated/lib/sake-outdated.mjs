import path, { dirname, join } from 'path';
import fs from 'fs';
import tmp from 'tmp';

// src/npmfix.coffee
var npmFix = function() {
  return new Promise(function(resolve, reject) {
    var err, npmLog, npmPath;
    try {
      require('npm');
      return resolve(true);
    } catch (error) {
      err = error;
      if (/log.gauge.isEnabled/.test(err.stack.toString())) {
        console.log('Attempting to fix npm...');
        npmPath = join(dirname(require.resolve('npm')), '../');
        npmLog = join(npmPath, 'node_modules', 'npmlog');
        return fs.exists(npmLog, function(exists) {
          var cmd;
          if (exists) {
            cmd = "rm -rf " + npmLog;
            console.log(cmd);
            return exec(cmd).then(resolve)["catch"](reject);
          } else {
            return reject('Unable to apply npmfix');
          }
        });
      }
    }
  });
};

// src/replacements.coffee
var replacements = [
  {
    from: 'Run ncu with -u to upgrade package.json',
    to: "Run 'sake outdated:update' to update your package.json"
  }, {
    from: 'The following dependencies are satisfied by their declared version range, but the installed versions are behind. You can install the latest versions without modifying your package file by using npm update. If you want to update the dependencies in your package file anyway, run ncu -a.',
    to: "The following dependencies are satisfied by their declared version ranges. Run\n'sake outdated:all' to update your package.json to the latest versions."
  }, {
    from: 'The following dependency is satisfied by its declared version range, but the installed version is behind. You can install the latest version without modifying your package file by using npm update. If you want to update the dependency in your package file anyway, run ncu -a.',
    to: "The following dependency is satisfied by its declared version range. Run 'sake\noutdated:all' to update your package.json to the latest version instead."
  }, {
    from: 'All dependencies match the latest package versions :)',
    to: 'All dependencies up to date'
  }, {
    from: 'Upgraded /',
    to: 'Updated /'
  }
];

// src/utils.coffee
var log = function(stdout, stderr) {
  var from, j, len, ref, to;
  stdout = stdout.trim();
  stderr = stderr.trim();
  for (j = 0, len = replacements.length; j < len; j++) {
    ref = replacements[j], from = ref.from, to = ref.to;
    stdout = stdout.replace(from, to);
  }
  if (stdout) {
    console.log(stdout);
  }
  if (stderr) {
    return console.error(stderr);
  }
};

var gitExists = function() {
  return new Promise(function(resolve, reject) {
    return exec.quiet('git rev-parse --git-dir').then(function(arg) {
      var stderr;
      stderr = arg.stderr;
      if (/fatal: Not a git repository/.test(stderr)) {
        return resolve(false);
      } else {
        return resolve(true);
      }
    });
  });
};

var gitOk = function() {
  return new Promise(function(resolve, reject) {
    return gitExists().then(function(exists) {
      if (!exists) {
        return resolve(true);
      }
      return exec.quiet('git status --porcelain').then(function(arg) {
        var stderr, stdout;
        stderr = arg.stderr, stdout = arg.stdout;
        if (stderr || stdout) {
          console.error(stdout + stderr);
          return reject(new Error('Git working directory not clean'));
        } else {
          return resolve(true);
        }
      });
    });
  });
};

var splitLines = function(stdout) {
  var i, j, k, len, len1, line, lines;
  lines = stdout.split('\n');
  lines = lines.slice(2, -4);
  for (i = j = 0, len = lines.length; j < len; i = ++j) {
    line = lines[i];
    lines[i] = '  ' + line.trim();
  }
  for (i = k = 0, len1 = lines.length; k < len1; i = ++k) {
    line = lines[i];
    if (/The following dependenc/.test(line)) {
      return lines.slice(0, i);
    }
  }
  return lines;
};

var parseDeps = function(lines) {
  var dep, j, len, results;
  results = [];
  for (j = 0, len = lines.length; j < len; j++) {
    dep = lines[j];
    dep = (dep.trim().split(' ')).shift();
    if (dep === '') {
      continue;
    }
    results.push(dep);
  }
  return results;
};

var needsUpdate = function(stdout) {
  return /Upgraded .*package\.json/.test(stdout);
};

var stripNcu = function(stdout) {
  var j, len, messages, msg;
  messages = ['\nThe following dependencies are satisfied by their declared version range, but the installed versions are behind. You can install the latest versions without modifying your package file by using npm update. If you want to update the dependencies in your package file anyway, run ncu -a.\n', '\nThe following dependency is satisfied by its declared version range, but the installed version is behind. You can install the latest version without modifying your package file by using npm update. If you want to update the dependency in your package file anyway, run ncu -a.\n'];
  for (j = 0, len = messages.length; j < len; j++) {
    msg = messages[j];
    stdout = stdout.replace(msg, '');
  }
  return stdout;
};

// src/update.coffee
var write;

write = function(data) {
  return new Promise(function(resolve, reject) {
    return tmp.file(function(err, path$$1, fd) {
      if (err != null) {
        return reject(err);
      }
      return fs.writeFile(fd, data, function(err) {
        if (err != null) {
          return reject(err);
        } else {
          return resolve(path$$1);
        }
      });
    });
  });
};

var update = function(stdout) {
  return new Promise(function(resolve, reject) {
    return gitExists().then(function(exists) {
      var cmds, deps, lines, message, path$$1;
      if (exists) {
        lines = splitLines(stdout);
        deps = parseDeps(lines);
        message = "Update " + (deps.join(', ')) + "\n\n" + (lines.join('\n'));
        path$$1 = null;
        cmds = [
          'echo', 'git add .', function() {
            return (write(message)).then(function(v) {
              return path$$1 = v;
            });
          }, function() {
            return "git commit -F " + path$$1;
          }
        ];
      } else {
        cmds = [];
      }
      if (tasks.has('yarn:upgrade')) {
        cmds.unshift('yarn upgrade');
        cmds.unshift('echo');
      } else {
        cmds.push('echo');
        cmds.push('npm update');
      }
      return exec(cmds).then(resolve)["catch"](reject);
    });
  });
};

// src/index.coffee
var index = function(opts) {
  var ncu, ncuBin, ncuPath;
  if (opts == null) {
    opts = {};
  }
  if (opts.commit == null) {
    opts.commit = true;
  }
  if (Array.isArray(opts.ignore)) {
    opts.ignore = opts.ignore.join(',');
  } else {
    if (opts.ignore == null) {
      opts.ignore = null;
    }
  }
  ncuPath = path.dirname(require.resolve('npm4-check-updates'));
  ncuBin = path.join(ncuPath, '../bin/ncu');
  ncu = opts.ignore != null ? ncuBin + " -x " + opts.ignore : ncuBin;
  task('outdated', 'show outdated packages', function*() {
    var ref, status, stderr, stdout;
    if (!(yield npmFix())) {
      return;
    }
    ref = (yield exec.quiet(ncu)), stdout = ref.stdout, stderr = ref.stderr, status = ref.status;
    log(stdout, stderr);
    if (status !== 0) {
      return process.exit(status);
    }
  });
  task('outdated:update', 'update outdated packages', function*() {
    var ref, status, stderr, stdout;
    if (!(yield npmFix())) {
      return;
    }
    if (!(yield gitOk())) {
      return;
    }
    ref = (yield exec.quiet(ncu + ' -u')), stdout = ref.stdout, stderr = ref.stderr, status = ref.status;
    log(stdout, stderr);
    if (status !== 0) {
      process.exit(status);
    }
    if (needsUpdate(stdout)) {
      if (opts.commit) {
        return (yield update(stdout));
      }
    }
  });
  return task('outdated:all', 'update all outdated packages', function*() {
    var ref, status, stderr, stdout;
    if (!(yield npmFix())) {
      return;
    }
    if (!(yield gitOk())) {
      return;
    }
    ref = (yield exec.quiet(ncu + ' -u -a')), stdout = ref.stdout, stderr = ref.stderr, status = ref.status;
    stdout = stripNcu(stdout);
    log(stdout, stderr);
    if (status !== 0) {
      process.exit(status);
    }
    if (needsUpdate(stdout)) {
      if (opts.commit) {
        return (yield update(stdout));
      }
    }
  });
};

export default index;
//# sourceMappingURL=sake-outdated.mjs.map
