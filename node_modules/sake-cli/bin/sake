#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs'));
var sake = require('sake-core');
var sake__default = _interopDefault(sake);
var yargs = _interopDefault(require('yargs'));
var path = _interopDefault(require('path'));
var findCoffee = _interopDefault(require('find-coffee'));

// src/transform.coffee
var transform;

var transform$1 = transform = function(code) {
  var babel, esModules, out;
  babel = require('babel-core');
  esModules = require('babel-plugin-transform-es2015-modules-commonjs');
  out = babel.transform(code, {
    plugins: [
      [
        esModules, {
          loose: true
        }
      ]
    ]
  });
  return out.code;
};

// src/cache.coffee
var cache;
var cacheDir;
var cachePath;
var load;
var mkdirp;
var read;
var requireCached;
var write;

cacheDir = function(dir) {
  return path.resolve(path.join(dir, '.sake'));
};

cachePath = function(dir) {
  return path.join(cacheDir(dir), 'Sakefile.js');
};

mkdirp = function(dir) {
  var err;
  try {
    return fs.mkdirSync(dir);
  } catch (error) {
    err = error;
    if (err.code !== 'EEXIST') {
      throw err;
    }
  }
};

read = function(dir) {
  return fs.readFileSync(cachePath(dir), 'utf8');
};

write = function(dir, code) {
  var transformed;
  mkdirp(cacheDir(dir));
  transformed = transform$1(code);
  return fs.writeFileSync(cachePath(dir), transformed, 'utf8');
};

requireCached = function(dir) {
  var err, tempFile;
  tempFile = path.resolve(path.join(dir, "__Sakefile.js"));
  fs.linkSync(cachePath(dir), tempFile);
  try {
    require(tempFile);
  } catch (error) {
    err = error;
  }
  fs.unlinkSync(tempFile);
  if (err != null) {
    throw err;
  }
};

load = function(dir, file) {
  var cached, err, source;
  try {
    cached = fs.statSync(cachePath(dir));
    source = fs.statSync(path.join(dir, file));
  } catch (error) {
    err = error;
    if (err.code === 'ENOENT') {
      return false;
    }
    throw err;
  }
  if (cached.mtime > source.mtime) {
    requireCached(dir);
    return true;
  } else {
    return false;
  }
};

var cache$1 = cache = {
  load: load,
  require: requireCached,
  write: write
};

// src/load.coffee
var load$1;
var loadCakefile;
var loadSakefile;
var loadSakefileTs;

loadCakefile = function(dir, file) {
  var code, coffee, js;
  if (cache$1.load(dir, file)) {
    return;
  }
  coffee = findCoffee();
  coffee.register();
  code = fs.readFileSync(file, 'utf8');
  js = coffee.compile(code, {
    bare: true,
    filename: file,
    sourceMap: false
  });
  cache$1.write(dir, js);
  return cache$1.require(dir);
};

loadSakefile = function(dir, file) {
  var code, err;
  if (cache$1.load(dir, file)) {
    return;
  }
  try {
    code = fs.readFileSync(file, 'utf8');
    cache$1.write(dir, code);
    return cache$1.require(dir);
  } catch (error) {
    err = error;
    if ((path.extname(file)) !== '') {
      throw err;
    }
    if (err.constructor.name !== 'SyntaxError') {
      throw err;
    }
    return loadCakefile(dir, file);
  }
};

loadSakefileTs = function(dir, file) {
  if (cache$1.load(dir, file)) {
    return;
  }
  exec.sync("tsc --types sake-core --outFile .sake/Sakefile.js Sakefile.ts");
  return cache$1.require(dir);
};

var load$2 = load$1 = {
  Cakefile: loadCakefile,
  Sakefile: loadSakefile,
  SakefileTs: loadSakefileTs
};

// src/utils.coffee


var findSakefile = function(dir) {
  var file, i, len, parent, ref;
  ref = ['Sakefile', 'Sakefile.js', 'Cakefile', 'Sakefile.ts'];
  for (i = 0, len = ref.length; i < len; i++) {
    file = ref[i];
    if (fs.existsSync(path.join(dir, file))) {
      return {
        file: file,
        dir: dir
      };
    }
  }
  parent = path.normalize(path.join(dir, '..'));
  if (parent !== dir) {
    return findSakefile(parent);
  }
  throw new Error("Sakefile not found in " + (process.cwd()));
};

var printTasks = function(dir, file) {
  var desc, filePath, i, len, name, names, relative, results, spaces, task;
  relative = path.relative || path.resolve;
  filePath = path.join(relative(__originalDirname, process.cwd()), file);
  console.log(filePath + " defines the following tasks:\n");
  delete sake.tasks.has;
  names = Object.keys(sake.tasks).sort();
  results = [];
  for (i = 0, len = names.length; i < len; i++) {
    name = names[i];
    task = sake.tasks[name];
    spaces = 20 - name.length;
    spaces = spaces > 0 ? Array(spaces + 1).join(' ') : '';
    desc = task.description ? "# " + task.description : '';
    results.push(console.log("sake " + name + spaces + " " + desc));
  }
  return results;
};

var fatalError = function(message) {
  console.error(message + '\n');
  console.log('To see a list of all tasks/options, run "sake"');
  return process.exit(1);
};

var missingTask = function(task) {
  return fatalError("No such task: " + task);
};

// package.json

var version = "0.5.21";

// src/run.coffee
var run;

var run$1 = run = function() {
  var argv, dir, file, i, len, ref, task, tasks$$1;
  global.__originalDirname = fs.realpathSync('.');
  ref = findSakefile(__originalDirname), dir = ref.dir, file = ref.file;
  process.chdir(dir);
  argv = yargs.argv;
  tasks$$1 = argv._.slice(0);
  argv["arguments"] = argv._;
  if (argv.debug) {
    process.env.VERBOSE = true;
  }
  if (argv.version || argv.v && !argv._.length) {
    console.log(version + " (core: " + sake__default.version + ")");
    process.exit(0);
  }
  sake__default.install();
  if (!cache$1.load(dir, file)) {
    switch (file) {
      case 'Cakefile':
        load$2.Cakefile(dir, file);
        break;
      case 'Sakefile':
      case 'Sakefile.js':
        load$2.Sakefile(dir, file);
        break;
      case 'Sakefile.ts':
        load$2.SakefileTs(dir, file);
    }
  }
  if (!argv._.length) {
    return printTasks(dir, file);
  }
  for (i = 0, len = tasks$$1.length; i < len; i++) {
    task = tasks$$1[i];
    if (sake__default.tasks[task] == null) {
      missingTask(task);
    }
  }
  return sake__default.invoke(tasks$$1, argv, function(err) {
    if (err != null) {
      console.error(err);
      return process.exit(1);
    }
  });
};

// src/cli.coffee
run$1();
//# sourceMappingURL=sake.map
