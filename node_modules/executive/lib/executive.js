'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var child_process = require('child_process');
var Stream = _interopDefault(require('stream'));
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));
var shellQuote = _interopDefault(require('shell-quote'));

// node_modules/es-is/dist/index.mjs
// src/index.coffee
var isActualNaN;
var isArgs;
var isFn;
var objProto;
var owns;
var symbolValueOf;
var toStr;

objProto = Object.prototype;

owns = objProto.hasOwnProperty;

toStr = objProto.toString;

symbolValueOf = void 0;

if (typeof Symbol === 'function') {
  symbolValueOf = Symbol.prototype.valueOf;
}

isActualNaN = function(value) {
  return value !== value;
};

var isEqual = function(value, other) {
  var key, type;
  if (value === other) {
    return true;
  }
  type = toStr.call(value);
  if (type !== toStr.call(other)) {
    return false;
  }
  if (type === '[object Object]') {
    for (key in value) {
      if (!isEqual(value[key], other[key]) || !(key in other)) {
        return false;
      }
    }
    for (key in other) {
      if (!isEqual(value[key], other[key]) || !(key in value)) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Array]') {
    key = value.length;
    if (key !== other.length) {
      return false;
    }
    while (key--) {
      if (!isEqual(value[key], other[key])) {
        return false;
      }
    }
    return true;
  }
  if (type === '[object Function]') {
    return value.prototype === other.prototype;
  }
  if (type === '[object Date]') {
    return value.getTime() === other.getTime();
  }
  return false;
};

var isArrayLike = function(value) {
  return !!value && !isBool(value) && owns.call(value, 'length') && isFinite(value.length) && isNumber(value.length) && value.length >= 0;
};

var isArguments = isArgs = function(value) {
  var isOldArguments, isStandardArguments;
  isStandardArguments = toStr.call(value) === '[object Arguments]';
  isOldArguments = !isArray(value) && isArrayLike(value) && isObject(value) && isFn(value.callee);
  return isStandardArguments || isOldArguments;
};

var isArray = Array.isArray || function(value) {
  return toStr.call(value) === '[object Array]';
};

var isBool = function(value) {
  return toStr.call(value) === '[object Boolean]';
};

var isFunction = isFn = function(value) {
  var isAlert, str;
  isAlert = typeof window !== 'undefined' && value === window.alert;
  if (isAlert) {
    return true;
  }
  str = toStr.call(value);
  return str === '[object Function]' || str === '[object GeneratorFunction]' || str === '[object AsyncFunction]';
};

var isNumber = function(value) {
  return toStr.call(value) === '[object Number]';
};

var isObject = function(value) {
  return toStr.call(value) === '[object Object]';
};

var isPromise = function(value) {
  return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';
};

var isString = function(value) {
  return toStr.call(value) === '[object String]';
};

// src/buffer-stream.coffee
var BufferStream;
var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
var hasProp = {}.hasOwnProperty;

BufferStream = (function(superClass) {
  extend(BufferStream, superClass);

  function BufferStream() {
    BufferStream.__super__.constructor.call(this);
    this.buffer = '';
    this.writable = true;
  }

  BufferStream.prototype.write = function(data) {
    return this.buffer += data;
  };

  BufferStream.prototype.end = function(data) {
    if (arguments.length) {
      this.write(data);
    }
    return this.writable = false;
  };

  BufferStream.prototype.destroy = function() {
    return this.writable = false;
  };

  BufferStream.prototype.toString = function() {
    return this.buffer;
  };

  return BufferStream;

})(Stream);

var BufferStream$1 = BufferStream;

// src/utils.coffee
var isWin = /^win/.test(process.platform);

var logError = function(err) {
  if ((err.code === 'ENOENT') && /^spawn/.test(err.syscall)) {
    console.error("Error: " + err.code + ", " + err.syscall);
    return console.error("Make sure '" + err.cmd + "' exists and is executable.");
  }
};

var once = function(fn) {
  var ran, result;
  ran = false;
  result = null;
  return function() {
    if (ran) {
      return result;
    }
    ran = true;
    result = fn.apply(this, arguments);
    fn = null;
    return result;
  };
};

// src/parse.coffee
var argsObject;
var argsString;
var shellRequired;

shellRequired = function(args) {
  var arg, i, len;
  for (i = 0, len = args.length; i < len; i++) {
    arg = args[i];
    if (!isString(arg)) {
      return true;
    }
  }
  return false;
};

argsString = function(s, opts, env) {
  var args, cmd, k, ref, ref1, v;
  args = shellQuote.parse(s);
  while (cmd = args.shift()) {
    if ((cmd.indexOf('=')) === -1) {
      break;
    }
    ref = cmd.split('=', 2), k = ref[0], v = ref[1];
    env[k] = v;
  }
  if (!isWin) {
    if ((opts.shell != null) || shellRequired(args)) {
      cmd = (ref1 = opts.shell) != null ? ref1 : '/bin/sh';
      args = ['-c', s];
    }
  }
  return [cmd, args, env];
};

argsObject = function(obj, opts, env) {
  var args, cmd, ref, ref1;
  cmd = obj.cmd;
  env = Object.assign(env, (ref = obj.env) != null ? ref : {});
  args = (ref1 = obj.args) != null ? ref1 : [];
  return [cmd, args, env];
};

var parse = function(args, opts) {
  var cmd, cmd_, env, ref, ref1, ref2;
  if (opts == null) {
    opts = {};
  }
  env = Object.assign(process.env, (ref = opts.env) != null ? ref : {});
  if (isString(args)) {
    ref1 = argsString(args, opts, env), cmd = ref1[0], args = ref1[1], env = ref1[2];
  } else {
    ref2 = argsObject(args, opts, env), cmd = ref2[0], args = ref2[1], env = ref2[2];
  }
  opts.env = env;
  if (isWin) {
    cmd = path.normalize(cmd);
    if (fs.existsSync(cmd_ = cmd + '.cmd')) {
      cmd = cmd_;
    }
    args = ['/c', cmd].concat(args);
    cmd = 'cmd.exe';
  }
  return [cmd, args, opts];
};

// src/exec.coffee
var exec = function(cmd, opts, cb) {
  var args, child, done, exit, ref, ref1, ref2, ref3, stderr, stdout;
  ref = parse(cmd, opts), cmd = ref[0], args = ref[1], opts = ref[2];
  stderr = new BufferStream$1();
  stdout = new BufferStream$1();
  child = child_process.spawn(cmd, args, {
    cwd: opts.cwd,
    env: opts.env,
    stdio: (ref1 = opts.stdio) != null ? ref1 : [0, 'pipe', 'pipe'],
    detached: opts.detached,
    uid: opts.uid,
    gid: opts.gid
  });
  child.setMaxListeners(0);
  child.stdout.setEncoding((ref2 = opts.encoding) != null ? ref2 : 'utf8');
  child.stderr.setEncoding((ref3 = opts.encoding) != null ? ref3 : 'utf8');
  if (!opts.interactive) {
    child.stdout.pipe(stdout);
    child.stderr.pipe(stderr);
  }
  if (!opts.quiet) {
    child.stdout.pipe(process.stdout);
    child.stderr.pipe(process.stderr);
  }
  done = once(function(err, status) {
    stdout.destroy();
    stderr.destroy();
    child.kill();
    stdout = stdout.toString();
    stderr = stderr.toString();
    if (err != null) {
      err.cmd = cmd;
      err.args = args;
      err.stdout = stdout;
      err.stderr = stderr;
      err.status = status;
      if (!opts.quiet) {
        logError(err);
      }
    }
    return cb(err, stdout, stderr, status);
  });
  exit = once(function(status, signal) {
    var err;
    err = null;
    if (status !== 0) {
      err = new Error("Command failed, '" + cmd + "' exited with status " + status);
      err.signal = signal;
    }
    return done(err, status);
  });
  child.on('close', exit);
  child.on('error', done);
  return child;
};

// src/execSync.coffee
var execSync = function(cmd, opts, cb) {
  var args, error, output, pid, ref, ref1, ref2, ref3, signal, status, stderr, stdout;
  ref = parse(cmd, opts), cmd = ref[0], args = ref[1], opts = ref[2];
  ref3 = child_process.spawnSync(cmd, args, {
    cwd: opts.cwd,
    input: opts.input,
    stdio: (ref1 = opts.stdio) != null ? ref1 : [0, 'pipe', 'pipe'],
    env: opts.env,
    uid: opts.uid,
    gid: opts.gid,
    timeout: opts.timeout,
    killSignal: opts.killSignal,
    maxBuffer: opts.maxBuffer,
    encoding: (ref2 = opts.encoding) != null ? ref2 : 'utf8'
  }), pid = ref3.pid, output = ref3.output, stdout = ref3.stdout, stderr = ref3.stderr, status = ref3.status, signal = ref3.signal, error = ref3.error;
  opts;
  if (!opts.quiet) {
    process.stdout.write(stdout);
    process.stderr.write(stderr);
  }
  if ((error == null) && status !== 0) {
    error = new Error("Command failed, '" + cmd + "' exited with status " + status);
  }
  if (error != null) {
    error.status = status;
    error.pid = pid;
    error.signal = signal;
    error.stderr = stderr;
    error.stdout = stdout;
    if (!opts.quiet) {
      logError(error);
    }
  }
  cb(error, stdout, stderr, status);
  return {
    status: status,
    stderr: stderr,
    stdout: stdout,
    error: error
  };
};

// src/flow.coffee
var serial = function(fn, cmds, opts, cb) {
  var append, errAll, lastStatus, next, outAll;
  errAll = '';
  outAll = '';
  lastStatus = null;
  append = function(res) {
    var status, stderr, stdout;
    if (res == null) {
      res = {};
    }
    stdout = res.stdout, stderr = res.stderr, status = res.status;
    if (stdout != null) {
      outAll += stdout;
    }
    if (stderr != null) {
      errAll += stderr;
    }
    if (status != null) {
      return lastStatus = status;
    } else {
      return lastStatus = 0;
    }
  };
  return (next = function() {
    var cmd, err, val;
    if (!cmds.length) {
      return cb(null, outAll, errAll, lastStatus);
    }
    cmd = cmds.shift();
    if (isString(cmd)) {
      return fn(cmd, opts, function(err, stdout, stderr, status) {
        outAll += stdout;
        errAll += stderr;
        lastStatus = status;
        if (opts.strict && (err != null)) {
          return cb(err, outAll, errAll, lastStatus);
        } else {
          return next();
        }
      });
    } else if (isPromise(cmd)) {
      return cmd.then(function(val) {
        append(val);
        return next();
      })["catch"](function(err) {
        return cb(err, outAll, errAll, 1);
      });
    } else if (isFunction(cmd)) {
      try {
        val = cmd();
        if ((isPromise(val)) || (isString(val))) {
          cmds.unshift(val);
        } else {
          append(val);
        }
        return next();
      } catch (error) {
        err = error;
        return cb(err, outAll, errAll, 1);
      }
    } else {
      return cb(new Error("Not a valid command: " + (cmd.toString())));
    }
  })();
};

var parallel = function(fn, cmds, opts, cb) {
  var append, cmd, done, err, errAll, errors, outAll, todo, val;
  outAll = '';
  errAll = '';
  errors = [];
  todo = cmds.length;
  append = function(res) {
    var status, stderr, stdout;
    if (res == null) {
      res = {};
    }
    stdout = res.stdout, stderr = res.stderr, status = res.status;
    if (stdout != null) {
      outAll += stdout;
    }
    if (stderr != null) {
      errAll += stderr;
    }
    if (status != null) {
      return status;
    } else {
      return 0;
    }
  };
  done = function(err, status) {
    if (status == null) {
      status = 0;
    }
    if (err != null) {
      if (!opts.quiet) {
        console.error(err);
        console.error(err.stack);
      }
      errors.push(err);
    }
    if (--todo) {
      return;
    }
    if (errors.length) {
      err = new Error('Partial completion');
      err.errors = errors;
      status = 1;
    }
    return cb(err, outAll, errAll, status);
  };
  while (cmds.length) {
    cmd = cmds.shift();
    if (isString(cmd)) {
      fn(cmd, opts, function(err, stdout, stderr, status) {
        append({
          stdout: stdout,
          stderr: stderr
        });
        return done(err, status);
      });
    } else if (isFunction(cmd)) {
      try {
        val = cmd();
        if (isPromise(val)) {
          cmds.push(val);
        } else if (isString(val)) {
          cmds.push(val);
        } else {
          append(val);
          done(null, 0);
        }
      } catch (error) {
        err = error;
        done(err);
      }
    } else if (isPromise(cmd)) {
      cmd.then(function(val) {
        append(val);
        return done(null, 0);
      })["catch"](function(err) {
        return done(err);
      });
    }
  }
};

// src/executive.coffee
var executive = function(cmds, opts, cb) {
  var err, executor, flow, out, ref;
  if (isString(cmds)) {
    cmds = (cmds.split('\n')).filter(function(c) {
      return c !== '';
    });
  }
  if (!isArray(cmds)) {
    cmds = [cmds];
  }
  if (isFunction(opts)) {
    ref = [opts, {}], cb = ref[0], opts = ref[1];
  }
  if (opts == null) {
    opts = {};
  }
  executor = exec;
  flow = serial;
  if (opts.sync) {
    executor = execSync;
  }
  if (opts.parallel) {
    flow = parallel;
  }
  if (cb && isFunction(cb)) {
    return flow(executor, cmds, opts, cb);
  }
  if (opts.sync) {
    out = '';
    err = '';
    return flow(executor, cmds, opts, function(err, stdout, stderr, status) {
      if (!opts.syncThrows) {
        return;
      }
      if (opts.strict && status !== 0) {
        throw err;
      } else if ((err != null) && (status == null)) {
        throw err;
      }
    });
  }
  return new Promise(function(resolve, reject) {
    return flow(executor, cmds, opts, function(err, stdout, stderr, status) {
      if (opts.strict && status !== 0) {
        return reject(err);
      } else if ((err != null) && (status == null)) {
        return reject(err);
      }
      return resolve({
        stdout: stdout,
        stderr: stderr,
        status: status
      });
    });
  });
};

// src/index.coffee
var partial;
var wrapper;

partial = function(defaults) {
  return function(cmds, opts, cb) {
    var ref;
    if (isFunction(opts)) {
      ref = [opts, {}], cb = ref[0], opts = ref[1];
    }
    opts = Object.assign({}, defaults, opts != null ? opts : {});
    return executive(cmds, opts, cb);
  };
};

wrapper = partial({
  quiet: false,
  interactive: false,
  sync: false
});

wrapper.interactive = partial({
  interactive: true
});

wrapper.parallel = partial({
  parallel: true
});

wrapper.serial = partial({
  parallel: false
});

wrapper.quiet = partial({
  quiet: true
});

wrapper.sync = partial({
  sync: true
});

var wrapper$1 = wrapper;

module.exports = wrapper$1;
//# sourceMappingURL=executive.js.map
